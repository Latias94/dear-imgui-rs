/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDockRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDockNodeSettings {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STB_TexteditState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stbrp_node {
    _unused: [u8; 0],
}
pub type ImS8 = ::std::os::raw::c_schar;
pub type ImU8 = ::std::os::raw::c_uchar;
pub type ImS16 = ::std::os::raw::c_short;
pub type ImU16 = ::std::os::raw::c_ushort;
pub type ImS32 = ::std::os::raw::c_int;
pub type ImU32 = ::std::os::raw::c_uint;
pub type ImS64 = ::std::os::raw::c_longlong;
pub type ImU64 = ::std::os::raw::c_ulonglong;
pub type ImGuiCol = ::std::os::raw::c_int;
pub type ImGuiCond = ::std::os::raw::c_int;
pub type ImGuiMouseCursor = ::std::os::raw::c_int;
pub type ImGuiStyleVar = ::std::os::raw::c_int;
pub type ImDrawListFlags = ::std::os::raw::c_int;
pub type ImFontFlags = ::std::os::raw::c_int;
pub type ImFontAtlasFlags = ::std::os::raw::c_int;
pub type ImGuiBackendFlags = ::std::os::raw::c_int;
pub type ImGuiChildFlags = ::std::os::raw::c_int;
pub type ImGuiColorEditFlags = ::std::os::raw::c_int;
pub type ImGuiConfigFlags = ::std::os::raw::c_int;
pub type ImGuiDockNodeFlags = ::std::os::raw::c_int;
pub type ImGuiDragDropFlags = ::std::os::raw::c_int;
pub type ImGuiHoveredFlags = ::std::os::raw::c_int;
pub type ImGuiInputFlags = ::std::os::raw::c_int;
pub type ImGuiInputTextFlags = ::std::os::raw::c_int;
pub type ImGuiItemFlags = ::std::os::raw::c_int;
pub type ImGuiKeyChord = ::std::os::raw::c_int;
pub type ImGuiListClipperFlags = ::std::os::raw::c_int;
pub type ImGuiMultiSelectFlags = ::std::os::raw::c_int;
pub type ImGuiTabBarFlags = ::std::os::raw::c_int;
pub type ImGuiTabItemFlags = ::std::os::raw::c_int;
pub type ImGuiTableFlags = ::std::os::raw::c_int;
pub type ImGuiTableColumnFlags = ::std::os::raw::c_int;
pub type ImGuiTableRowFlags = ::std::os::raw::c_int;
pub type ImGuiTreeNodeFlags = ::std::os::raw::c_int;
pub type ImGuiViewportFlags = ::std::os::raw::c_int;
pub type ImGuiWindowFlags = ::std::os::raw::c_int;
pub type ImWchar16 = ::std::os::raw::c_ushort;
pub type ImWchar = ImWchar16;
pub type ImGuiSelectionUserData = ImS64;
pub type ImGuiSizeCallback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ImGuiSizeCallbackData)>;
#[repr(C)]
pub struct ImTextureRef {
    pub _TexData: *mut ImTextureData,
    pub _TexID: ImTextureID,
}
impl Default for ImTextureRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiDir_None: ImGuiDir = -1;
pub const ImGuiDir_Left: ImGuiDir = 0;
pub const ImGuiDir_Right: ImGuiDir = 1;
pub const ImGuiDir_Up: ImGuiDir = 2;
pub const ImGuiDir_Down: ImGuiDir = 3;
pub const ImGuiDir_COUNT: ImGuiDir = 4;
pub type ImGuiDir = ::std::os::raw::c_int;
pub const ImGuiSortDirection_None: ImGuiSortDirection = 0;
pub const ImGuiSortDirection_Ascending: ImGuiSortDirection = 1;
pub const ImGuiSortDirection_Descending: ImGuiSortDirection = 2;
pub type ImGuiSortDirection = ::std::os::raw::c_uint;
pub const ImGuiKey_None: ImGuiKey = 0;
pub const ImGuiKey_NamedKey_BEGIN: ImGuiKey = 512;
pub const ImGuiKey_Tab: ImGuiKey = 512;
pub const ImGuiKey_LeftArrow: ImGuiKey = 513;
pub const ImGuiKey_RightArrow: ImGuiKey = 514;
pub const ImGuiKey_UpArrow: ImGuiKey = 515;
pub const ImGuiKey_DownArrow: ImGuiKey = 516;
pub const ImGuiKey_PageUp: ImGuiKey = 517;
pub const ImGuiKey_PageDown: ImGuiKey = 518;
pub const ImGuiKey_Home: ImGuiKey = 519;
pub const ImGuiKey_End: ImGuiKey = 520;
pub const ImGuiKey_Insert: ImGuiKey = 521;
pub const ImGuiKey_Delete: ImGuiKey = 522;
pub const ImGuiKey_Backspace: ImGuiKey = 523;
pub const ImGuiKey_Space: ImGuiKey = 524;
pub const ImGuiKey_Enter: ImGuiKey = 525;
pub const ImGuiKey_Escape: ImGuiKey = 526;
pub const ImGuiKey_LeftCtrl: ImGuiKey = 527;
pub const ImGuiKey_LeftShift: ImGuiKey = 528;
pub const ImGuiKey_LeftAlt: ImGuiKey = 529;
pub const ImGuiKey_LeftSuper: ImGuiKey = 530;
pub const ImGuiKey_RightCtrl: ImGuiKey = 531;
pub const ImGuiKey_RightShift: ImGuiKey = 532;
pub const ImGuiKey_RightAlt: ImGuiKey = 533;
pub const ImGuiKey_RightSuper: ImGuiKey = 534;
pub const ImGuiKey_Menu: ImGuiKey = 535;
pub const ImGuiKey_0: ImGuiKey = 536;
pub const ImGuiKey_1: ImGuiKey = 537;
pub const ImGuiKey_2: ImGuiKey = 538;
pub const ImGuiKey_3: ImGuiKey = 539;
pub const ImGuiKey_4: ImGuiKey = 540;
pub const ImGuiKey_5: ImGuiKey = 541;
pub const ImGuiKey_6: ImGuiKey = 542;
pub const ImGuiKey_7: ImGuiKey = 543;
pub const ImGuiKey_8: ImGuiKey = 544;
pub const ImGuiKey_9: ImGuiKey = 545;
pub const ImGuiKey_A: ImGuiKey = 546;
pub const ImGuiKey_B: ImGuiKey = 547;
pub const ImGuiKey_C: ImGuiKey = 548;
pub const ImGuiKey_D: ImGuiKey = 549;
pub const ImGuiKey_E: ImGuiKey = 550;
pub const ImGuiKey_F: ImGuiKey = 551;
pub const ImGuiKey_G: ImGuiKey = 552;
pub const ImGuiKey_H: ImGuiKey = 553;
pub const ImGuiKey_I: ImGuiKey = 554;
pub const ImGuiKey_J: ImGuiKey = 555;
pub const ImGuiKey_K: ImGuiKey = 556;
pub const ImGuiKey_L: ImGuiKey = 557;
pub const ImGuiKey_M: ImGuiKey = 558;
pub const ImGuiKey_N: ImGuiKey = 559;
pub const ImGuiKey_O: ImGuiKey = 560;
pub const ImGuiKey_P: ImGuiKey = 561;
pub const ImGuiKey_Q: ImGuiKey = 562;
pub const ImGuiKey_R: ImGuiKey = 563;
pub const ImGuiKey_S: ImGuiKey = 564;
pub const ImGuiKey_T: ImGuiKey = 565;
pub const ImGuiKey_U: ImGuiKey = 566;
pub const ImGuiKey_V: ImGuiKey = 567;
pub const ImGuiKey_W: ImGuiKey = 568;
pub const ImGuiKey_X: ImGuiKey = 569;
pub const ImGuiKey_Y: ImGuiKey = 570;
pub const ImGuiKey_Z: ImGuiKey = 571;
pub const ImGuiKey_F1: ImGuiKey = 572;
pub const ImGuiKey_F2: ImGuiKey = 573;
pub const ImGuiKey_F3: ImGuiKey = 574;
pub const ImGuiKey_F4: ImGuiKey = 575;
pub const ImGuiKey_F5: ImGuiKey = 576;
pub const ImGuiKey_F6: ImGuiKey = 577;
pub const ImGuiKey_F7: ImGuiKey = 578;
pub const ImGuiKey_F8: ImGuiKey = 579;
pub const ImGuiKey_F9: ImGuiKey = 580;
pub const ImGuiKey_F10: ImGuiKey = 581;
pub const ImGuiKey_F11: ImGuiKey = 582;
pub const ImGuiKey_F12: ImGuiKey = 583;
pub const ImGuiKey_F13: ImGuiKey = 584;
pub const ImGuiKey_F14: ImGuiKey = 585;
pub const ImGuiKey_F15: ImGuiKey = 586;
pub const ImGuiKey_F16: ImGuiKey = 587;
pub const ImGuiKey_F17: ImGuiKey = 588;
pub const ImGuiKey_F18: ImGuiKey = 589;
pub const ImGuiKey_F19: ImGuiKey = 590;
pub const ImGuiKey_F20: ImGuiKey = 591;
pub const ImGuiKey_F21: ImGuiKey = 592;
pub const ImGuiKey_F22: ImGuiKey = 593;
pub const ImGuiKey_F23: ImGuiKey = 594;
pub const ImGuiKey_F24: ImGuiKey = 595;
pub const ImGuiKey_Apostrophe: ImGuiKey = 596;
pub const ImGuiKey_Comma: ImGuiKey = 597;
pub const ImGuiKey_Minus: ImGuiKey = 598;
pub const ImGuiKey_Period: ImGuiKey = 599;
pub const ImGuiKey_Slash: ImGuiKey = 600;
pub const ImGuiKey_Semicolon: ImGuiKey = 601;
pub const ImGuiKey_Equal: ImGuiKey = 602;
pub const ImGuiKey_LeftBracket: ImGuiKey = 603;
pub const ImGuiKey_Backslash: ImGuiKey = 604;
pub const ImGuiKey_RightBracket: ImGuiKey = 605;
pub const ImGuiKey_GraveAccent: ImGuiKey = 606;
pub const ImGuiKey_CapsLock: ImGuiKey = 607;
pub const ImGuiKey_ScrollLock: ImGuiKey = 608;
pub const ImGuiKey_NumLock: ImGuiKey = 609;
pub const ImGuiKey_PrintScreen: ImGuiKey = 610;
pub const ImGuiKey_Pause: ImGuiKey = 611;
pub const ImGuiKey_Keypad0: ImGuiKey = 612;
pub const ImGuiKey_Keypad1: ImGuiKey = 613;
pub const ImGuiKey_Keypad2: ImGuiKey = 614;
pub const ImGuiKey_Keypad3: ImGuiKey = 615;
pub const ImGuiKey_Keypad4: ImGuiKey = 616;
pub const ImGuiKey_Keypad5: ImGuiKey = 617;
pub const ImGuiKey_Keypad6: ImGuiKey = 618;
pub const ImGuiKey_Keypad7: ImGuiKey = 619;
pub const ImGuiKey_Keypad8: ImGuiKey = 620;
pub const ImGuiKey_Keypad9: ImGuiKey = 621;
pub const ImGuiKey_KeypadDecimal: ImGuiKey = 622;
pub const ImGuiKey_KeypadDivide: ImGuiKey = 623;
pub const ImGuiKey_KeypadMultiply: ImGuiKey = 624;
pub const ImGuiKey_KeypadSubtract: ImGuiKey = 625;
pub const ImGuiKey_KeypadAdd: ImGuiKey = 626;
pub const ImGuiKey_KeypadEnter: ImGuiKey = 627;
pub const ImGuiKey_KeypadEqual: ImGuiKey = 628;
pub const ImGuiKey_AppBack: ImGuiKey = 629;
pub const ImGuiKey_AppForward: ImGuiKey = 630;
pub const ImGuiKey_Oem102: ImGuiKey = 631;
pub const ImGuiKey_GamepadStart: ImGuiKey = 632;
pub const ImGuiKey_GamepadBack: ImGuiKey = 633;
pub const ImGuiKey_GamepadFaceLeft: ImGuiKey = 634;
pub const ImGuiKey_GamepadFaceRight: ImGuiKey = 635;
pub const ImGuiKey_GamepadFaceUp: ImGuiKey = 636;
pub const ImGuiKey_GamepadFaceDown: ImGuiKey = 637;
pub const ImGuiKey_GamepadDpadLeft: ImGuiKey = 638;
pub const ImGuiKey_GamepadDpadRight: ImGuiKey = 639;
pub const ImGuiKey_GamepadDpadUp: ImGuiKey = 640;
pub const ImGuiKey_GamepadDpadDown: ImGuiKey = 641;
pub const ImGuiKey_GamepadL1: ImGuiKey = 642;
pub const ImGuiKey_GamepadR1: ImGuiKey = 643;
pub const ImGuiKey_GamepadL2: ImGuiKey = 644;
pub const ImGuiKey_GamepadR2: ImGuiKey = 645;
pub const ImGuiKey_GamepadL3: ImGuiKey = 646;
pub const ImGuiKey_GamepadR3: ImGuiKey = 647;
pub const ImGuiKey_GamepadLStickLeft: ImGuiKey = 648;
pub const ImGuiKey_GamepadLStickRight: ImGuiKey = 649;
pub const ImGuiKey_GamepadLStickUp: ImGuiKey = 650;
pub const ImGuiKey_GamepadLStickDown: ImGuiKey = 651;
pub const ImGuiKey_GamepadRStickLeft: ImGuiKey = 652;
pub const ImGuiKey_GamepadRStickRight: ImGuiKey = 653;
pub const ImGuiKey_GamepadRStickUp: ImGuiKey = 654;
pub const ImGuiKey_GamepadRStickDown: ImGuiKey = 655;
pub const ImGuiKey_MouseLeft: ImGuiKey = 656;
pub const ImGuiKey_MouseRight: ImGuiKey = 657;
pub const ImGuiKey_MouseMiddle: ImGuiKey = 658;
pub const ImGuiKey_MouseX1: ImGuiKey = 659;
pub const ImGuiKey_MouseX2: ImGuiKey = 660;
pub const ImGuiKey_MouseWheelX: ImGuiKey = 661;
pub const ImGuiKey_MouseWheelY: ImGuiKey = 662;
pub const ImGuiKey_ReservedForModCtrl: ImGuiKey = 663;
pub const ImGuiKey_ReservedForModShift: ImGuiKey = 664;
pub const ImGuiKey_ReservedForModAlt: ImGuiKey = 665;
pub const ImGuiKey_ReservedForModSuper: ImGuiKey = 666;
pub const ImGuiKey_NamedKey_END: ImGuiKey = 667;
pub const ImGuiKey_NamedKey_COUNT: ImGuiKey = 155;
pub const ImGuiMod_None: ImGuiKey = 0;
pub const ImGuiMod_Ctrl: ImGuiKey = 4096;
pub const ImGuiMod_Shift: ImGuiKey = 8192;
pub const ImGuiMod_Alt: ImGuiKey = 16384;
pub const ImGuiMod_Super: ImGuiKey = 32768;
pub const ImGuiMod_Mask_: ImGuiKey = 61440;
pub type ImGuiKey = ::std::os::raw::c_uint;
pub const ImGuiMouseSource_Mouse: ImGuiMouseSource = 0;
pub const ImGuiMouseSource_TouchScreen: ImGuiMouseSource = 1;
pub const ImGuiMouseSource_Pen: ImGuiMouseSource = 2;
pub const ImGuiMouseSource_COUNT: ImGuiMouseSource = 3;
pub type ImGuiMouseSource = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableSortSpecs {
    pub Specs: *const ImGuiTableColumnSortSpecs,
    pub SpecsCount: ::std::os::raw::c_int,
    pub SpecsDirty: bool,
}
impl Default for ImGuiTableSortSpecs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTableColumnSortSpecs {
    pub ColumnUserID: ImGuiID,
    pub ColumnIndex: ImS16,
    pub SortOrder: ImS16,
    pub SortDirection: ImGuiSortDirection,
}
impl Default for ImGuiTableColumnSortSpecs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiStyle {
    pub FontSizeBase: f32,
    pub FontScaleMain: f32,
    pub FontScaleDpi: f32,
    pub Alpha: f32,
    pub DisabledAlpha: f32,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub WindowBorderHoverPadding: f32,
    pub WindowMinSize: ImVec2,
    pub WindowTitleAlign: ImVec2,
    pub WindowMenuButtonPosition: ImGuiDir,
    pub ChildRounding: f32,
    pub ChildBorderSize: f32,
    pub PopupRounding: f32,
    pub PopupBorderSize: f32,
    pub FramePadding: ImVec2,
    pub FrameRounding: f32,
    pub FrameBorderSize: f32,
    pub ItemSpacing: ImVec2,
    pub ItemInnerSpacing: ImVec2,
    pub CellPadding: ImVec2,
    pub TouchExtraPadding: ImVec2,
    pub IndentSpacing: f32,
    pub ColumnsMinSpacing: f32,
    pub ScrollbarSize: f32,
    pub ScrollbarRounding: f32,
    pub ScrollbarPadding: f32,
    pub GrabMinSize: f32,
    pub GrabRounding: f32,
    pub LogSliderDeadzone: f32,
    pub ImageBorderSize: f32,
    pub TabRounding: f32,
    pub TabBorderSize: f32,
    pub TabMinWidthBase: f32,
    pub TabMinWidthShrink: f32,
    pub TabCloseButtonMinWidthSelected: f32,
    pub TabCloseButtonMinWidthUnselected: f32,
    pub TabBarBorderSize: f32,
    pub TabBarOverlineSize: f32,
    pub TableAngledHeadersAngle: f32,
    pub TableAngledHeadersTextAlign: ImVec2,
    pub TreeLinesFlags: ImGuiTreeNodeFlags,
    pub TreeLinesSize: f32,
    pub TreeLinesRounding: f32,
    pub ColorButtonPosition: ImGuiDir,
    pub ButtonTextAlign: ImVec2,
    pub SelectableTextAlign: ImVec2,
    pub SeparatorTextBorderSize: f32,
    pub SeparatorTextAlign: ImVec2,
    pub SeparatorTextPadding: ImVec2,
    pub DisplayWindowPadding: ImVec2,
    pub DisplaySafeAreaPadding: ImVec2,
    pub DockingNodeHasCloseButton: bool,
    pub DockingSeparatorSize: f32,
    pub MouseCursorScale: f32,
    pub AntiAliasedLines: bool,
    pub AntiAliasedLinesUseTex: bool,
    pub AntiAliasedFill: bool,
    pub CurveTessellationTol: f32,
    pub CircleTessellationMaxError: f32,
    pub Colors: [ImVec4; 61usize],
    pub HoverStationaryDelay: f32,
    pub HoverDelayShort: f32,
    pub HoverDelayNormal: f32,
    pub HoverFlagsForTooltipMouse: ImGuiHoveredFlags,
    pub HoverFlagsForTooltipNav: ImGuiHoveredFlags,
    pub _MainScale: f32,
    pub _NextFrameFontSizeBase: f32,
}
impl Default for ImGuiStyle {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiKeyData {
    pub Down: bool,
    pub DownDuration: f32,
    pub DownDurationPrev: f32,
    pub AnalogValue: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImWchar {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImWchar,
}
impl Default for ImVector_ImWchar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiIO {
    pub ConfigFlags: ImGuiConfigFlags,
    pub BackendFlags: ImGuiBackendFlags,
    pub DisplaySize: ImVec2,
    pub DisplayFramebufferScale: ImVec2,
    pub DeltaTime: f32,
    pub IniSavingRate: f32,
    pub IniFilename: *const ::std::os::raw::c_char,
    pub LogFilename: *const ::std::os::raw::c_char,
    pub UserData: *mut ::std::os::raw::c_void,
    pub Fonts: *mut ImFontAtlas,
    pub FontDefault: *mut ImFont,
    pub FontAllowUserScaling: bool,
    pub ConfigNavSwapGamepadButtons: bool,
    pub ConfigNavMoveSetMousePos: bool,
    pub ConfigNavCaptureKeyboard: bool,
    pub ConfigNavEscapeClearFocusItem: bool,
    pub ConfigNavEscapeClearFocusWindow: bool,
    pub ConfigNavCursorVisibleAuto: bool,
    pub ConfigNavCursorVisibleAlways: bool,
    pub ConfigDockingNoSplit: bool,
    pub ConfigDockingWithShift: bool,
    pub ConfigDockingAlwaysTabBar: bool,
    pub ConfigDockingTransparentPayload: bool,
    pub ConfigViewportsNoAutoMerge: bool,
    pub ConfigViewportsNoTaskBarIcon: bool,
    pub ConfigViewportsNoDecoration: bool,
    pub ConfigViewportsNoDefaultParent: bool,
    pub ConfigViewportsPlatformFocusSetsImGuiFocus: bool,
    pub ConfigDpiScaleFonts: bool,
    pub ConfigDpiScaleViewports: bool,
    pub MouseDrawCursor: bool,
    pub ConfigMacOSXBehaviors: bool,
    pub ConfigInputTrickleEventQueue: bool,
    pub ConfigInputTextCursorBlink: bool,
    pub ConfigInputTextEnterKeepActive: bool,
    pub ConfigDragClickToInputText: bool,
    pub ConfigWindowsResizeFromEdges: bool,
    pub ConfigWindowsMoveFromTitleBarOnly: bool,
    pub ConfigWindowsCopyContentsWithCtrlC: bool,
    pub ConfigScrollbarScrollByPage: bool,
    pub ConfigMemoryCompactTimer: f32,
    pub MouseDoubleClickTime: f32,
    pub MouseDoubleClickMaxDist: f32,
    pub MouseDragThreshold: f32,
    pub KeyRepeatDelay: f32,
    pub KeyRepeatRate: f32,
    pub ConfigErrorRecovery: bool,
    pub ConfigErrorRecoveryEnableAssert: bool,
    pub ConfigErrorRecoveryEnableDebugLog: bool,
    pub ConfigErrorRecoveryEnableTooltip: bool,
    pub ConfigDebugIsDebuggerPresent: bool,
    pub ConfigDebugHighlightIdConflicts: bool,
    pub ConfigDebugHighlightIdConflictsShowItemPicker: bool,
    pub ConfigDebugBeginReturnValueOnce: bool,
    pub ConfigDebugBeginReturnValueLoop: bool,
    pub ConfigDebugIgnoreFocusLoss: bool,
    pub ConfigDebugIniSettings: bool,
    pub BackendPlatformName: *const ::std::os::raw::c_char,
    pub BackendRendererName: *const ::std::os::raw::c_char,
    pub BackendPlatformUserData: *mut ::std::os::raw::c_void,
    pub BackendRendererUserData: *mut ::std::os::raw::c_void,
    pub BackendLanguageUserData: *mut ::std::os::raw::c_void,
    pub WantCaptureMouse: bool,
    pub WantCaptureKeyboard: bool,
    pub WantTextInput: bool,
    pub WantSetMousePos: bool,
    pub WantSaveIniSettings: bool,
    pub NavActive: bool,
    pub NavVisible: bool,
    pub Framerate: f32,
    pub MetricsRenderVertices: ::std::os::raw::c_int,
    pub MetricsRenderIndices: ::std::os::raw::c_int,
    pub MetricsRenderWindows: ::std::os::raw::c_int,
    pub MetricsActiveWindows: ::std::os::raw::c_int,
    pub MouseDelta: ImVec2,
    pub Ctx: *mut ImGuiContext,
    pub MousePos: ImVec2,
    pub MouseDown: [bool; 5usize],
    pub MouseWheel: f32,
    pub MouseWheelH: f32,
    pub MouseSource: ImGuiMouseSource,
    pub MouseHoveredViewport: ImGuiID,
    pub KeyCtrl: bool,
    pub KeyShift: bool,
    pub KeyAlt: bool,
    pub KeySuper: bool,
    pub KeyMods: ImGuiKeyChord,
    pub KeysData: [ImGuiKeyData; 155usize],
    pub WantCaptureMouseUnlessPopupClose: bool,
    pub MousePosPrev: ImVec2,
    pub MouseClickedPos: [ImVec2; 5usize],
    pub MouseClickedTime: [f64; 5usize],
    pub MouseClicked: [bool; 5usize],
    pub MouseDoubleClicked: [bool; 5usize],
    pub MouseClickedCount: [ImU16; 5usize],
    pub MouseClickedLastCount: [ImU16; 5usize],
    pub MouseReleased: [bool; 5usize],
    pub MouseReleasedTime: [f64; 5usize],
    pub MouseDownOwned: [bool; 5usize],
    pub MouseDownOwnedUnlessPopupClose: [bool; 5usize],
    pub MouseWheelRequestAxisSwap: bool,
    pub MouseCtrlLeftAsRightClick: bool,
    pub MouseDownDuration: [f32; 5usize],
    pub MouseDownDurationPrev: [f32; 5usize],
    pub MouseDragMaxDistanceAbs: [ImVec2; 5usize],
    pub MouseDragMaxDistanceSqr: [f32; 5usize],
    pub PenPressure: f32,
    pub AppFocusLost: bool,
    pub AppAcceptingEvents: bool,
    pub InputQueueSurrogate: ImWchar16,
    pub InputQueueCharacters: ImVector_ImWchar,
}
impl Default for ImGuiIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiSizeCallbackData {
    pub UserData: *mut ::std::os::raw::c_void,
    pub Pos: ImVec2,
    pub CurrentSize: ImVec2,
    pub DesiredSize: ImVec2,
}
impl Default for ImGuiSizeCallbackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiWindowClass {
    pub ClassId: ImGuiID,
    pub ParentViewportId: ImGuiID,
    pub FocusRouteParentWindowId: ImGuiID,
    pub ViewportFlagsOverrideSet: ImGuiViewportFlags,
    pub ViewportFlagsOverrideClear: ImGuiViewportFlags,
    pub TabItemFlagsOverrideSet: ImGuiTabItemFlags,
    pub DockNodeFlagsOverrideSet: ImGuiDockNodeFlags,
    pub DockingAlwaysTabBar: bool,
    pub DockingAllowUnclassed: bool,
}
impl Default for ImGuiWindowClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiPayload {
    pub Data: *mut ::std::os::raw::c_void,
    pub DataSize: ::std::os::raw::c_int,
    pub SourceId: ImGuiID,
    pub SourceParentId: ImGuiID,
    pub DataFrameCount: ::std::os::raw::c_int,
    pub DataType: [::std::os::raw::c_char; 33usize],
    pub Preview: bool,
    pub Delivery: bool,
}
impl Default for ImGuiPayload {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_char {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_char,
}
impl Default for ImVector_char {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextBuffer {
    pub Buf: ImVector_char,
}
impl Default for ImGuiTextBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiStoragePair {
    pub key: ImGuiID,
    pub __bindgen_anon_1: ImGuiStoragePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStoragePair__bindgen_ty_1 {
    pub val_i: ::std::os::raw::c_int,
    pub val_f: f32,
    pub val_p: *mut ::std::os::raw::c_void,
}
impl Default for ImGuiStoragePair__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ImGuiStoragePair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStoragePair {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiStoragePair,
}
impl Default for ImVector_ImGuiStoragePair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiStorage {
    pub Data: ImVector_ImGuiStoragePair,
}
impl Default for ImGuiStorage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiListClipper {
    pub Ctx: *mut ImGuiContext,
    pub DisplayStart: ::std::os::raw::c_int,
    pub DisplayEnd: ::std::os::raw::c_int,
    pub ItemsCount: ::std::os::raw::c_int,
    pub ItemsHeight: f32,
    pub StartPosY: f64,
    pub StartSeekOffsetY: f64,
    pub TempData: *mut ::std::os::raw::c_void,
    pub Flags: ImGuiListClipperFlags,
}
impl Default for ImGuiListClipper {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiSelectionRequest {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiSelectionRequest,
}
impl Default for ImVector_ImGuiSelectionRequest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiMultiSelectIO {
    pub Requests: ImVector_ImGuiSelectionRequest,
    pub RangeSrcItem: ImGuiSelectionUserData,
    pub NavIdItem: ImGuiSelectionUserData,
    pub NavIdSelected: bool,
    pub RangeSrcReset: bool,
    pub ItemsCount: ::std::os::raw::c_int,
}
impl Default for ImGuiMultiSelectIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiSelectionRequestType_None: ImGuiSelectionRequestType = 0;
pub const ImGuiSelectionRequestType_SetAll: ImGuiSelectionRequestType = 1;
pub const ImGuiSelectionRequestType_SetRange: ImGuiSelectionRequestType = 2;
pub type ImGuiSelectionRequestType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiSelectionRequest {
    pub Type: ImGuiSelectionRequestType,
    pub Selected: bool,
    pub RangeDirection: ImS8,
    pub RangeFirstItem: ImGuiSelectionUserData,
    pub RangeLastItem: ImGuiSelectionUserData,
}
impl Default for ImGuiSelectionRequest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImDrawIdx = ::std::os::raw::c_ushort;
pub type ImDrawCallback = ::std::option::Option<
    unsafe extern "C" fn(parent_list: *const ImDrawList, cmd: *const ImDrawCmd),
>;
#[repr(C)]
pub struct ImDrawCmd {
    pub ClipRect: ImVec4,
    pub TexRef: ImTextureRef,
    pub VtxOffset: ::std::os::raw::c_uint,
    pub IdxOffset: ::std::os::raw::c_uint,
    pub ElemCount: ::std::os::raw::c_uint,
    pub UserCallback: ImDrawCallback,
    pub UserCallbackData: *mut ::std::os::raw::c_void,
    pub UserCallbackDataSize: ::std::os::raw::c_int,
    pub UserCallbackDataOffset: ::std::os::raw::c_int,
}
impl Default for ImDrawCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImDrawVert {
    pub pos: ImVec2,
    pub uv: ImVec2,
    pub col: ImU32,
}
impl Default for ImDrawVert {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImDrawCmdHeader {
    pub ClipRect: ImVec4,
    pub TexRef: ImTextureRef,
    pub VtxOffset: ::std::os::raw::c_uint,
}
impl Default for ImDrawCmdHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawCmd {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawCmd,
}
impl Default for ImVector_ImDrawCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawIdx {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawIdx,
}
impl Default for ImVector_ImDrawIdx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawChannel {
    pub _CmdBuffer: ImVector_ImDrawCmd,
    pub _IdxBuffer: ImVector_ImDrawIdx,
}
impl Default for ImDrawChannel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawChannel {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawChannel,
}
impl Default for ImVector_ImDrawChannel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawListSplitter {
    pub _Current: ::std::os::raw::c_int,
    pub _Count: ::std::os::raw::c_int,
    pub _Channels: ImVector_ImDrawChannel,
}
impl Default for ImDrawListSplitter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawVert {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImDrawVert,
}
impl Default for ImVector_ImDrawVert {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImVec2 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImVec2,
}
impl Default for ImVector_ImVec2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImVec4 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImVec4,
}
impl Default for ImVector_ImVec4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImTextureRef {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImTextureRef,
}
impl Default for ImVector_ImTextureRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImU8 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImU8,
}
impl Default for ImVector_ImU8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawListPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImDrawList,
}
impl Default for ImVector_ImDrawListPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImTextureDataPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImTextureData,
}
impl Default for ImVector_ImTextureDataPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImDrawData {
    pub Valid: bool,
    pub CmdListsCount: ::std::os::raw::c_int,
    pub TotalIdxCount: ::std::os::raw::c_int,
    pub TotalVtxCount: ::std::os::raw::c_int,
    pub CmdLists: ImVector_ImDrawListPtr,
    pub DisplayPos: ImVec2,
    pub DisplaySize: ImVec2,
    pub FramebufferScale: ImVec2,
    pub OwnerViewport: *mut ImGuiViewport,
    pub Textures: *mut ImVector_ImTextureDataPtr,
}
impl Default for ImDrawData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImTextureFormat_RGBA32: ImTextureFormat = 0;
pub const ImTextureFormat_Alpha8: ImTextureFormat = 1;
pub type ImTextureFormat = ::std::os::raw::c_uint;
pub const ImTextureStatus_OK: ImTextureStatus = 0;
pub const ImTextureStatus_Destroyed: ImTextureStatus = 1;
pub const ImTextureStatus_WantCreate: ImTextureStatus = 2;
pub const ImTextureStatus_WantUpdates: ImTextureStatus = 3;
pub const ImTextureStatus_WantDestroy: ImTextureStatus = 4;
pub type ImTextureStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImTextureRect {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImTextureRect {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImTextureRect,
}
impl Default for ImVector_ImTextureRect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImTextureData {
    pub UniqueID: ::std::os::raw::c_int,
    pub Status: ImTextureStatus,
    pub BackendUserData: *mut ::std::os::raw::c_void,
    pub TexID: ImTextureID,
    pub Format: ImTextureFormat,
    pub Width: ::std::os::raw::c_int,
    pub Height: ::std::os::raw::c_int,
    pub BytesPerPixel: ::std::os::raw::c_int,
    pub Pixels: *mut ::std::os::raw::c_uchar,
    pub UsedRect: ImTextureRect,
    pub UpdateRect: ImTextureRect,
    pub Updates: ImVector_ImTextureRect,
    pub UnusedFrames: ::std::os::raw::c_int,
    pub RefCount: ::std::os::raw::c_ushort,
    pub UseColors: bool,
    pub WantDestroyNextFrame: bool,
}
impl Default for ImTextureData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImFontConfig {
    pub Name: [::std::os::raw::c_char; 40usize],
    pub FontData: *mut ::std::os::raw::c_void,
    pub FontDataSize: ::std::os::raw::c_int,
    pub FontDataOwnedByAtlas: bool,
    pub MergeMode: bool,
    pub PixelSnapH: bool,
    pub PixelSnapV: bool,
    pub OversampleH: ImS8,
    pub OversampleV: ImS8,
    pub EllipsisChar: ImWchar,
    pub SizePixels: f32,
    pub GlyphRanges: *const ImWchar,
    pub GlyphExcludeRanges: *const ImWchar,
    pub GlyphOffset: ImVec2,
    pub GlyphMinAdvanceX: f32,
    pub GlyphMaxAdvanceX: f32,
    pub GlyphExtraAdvanceX: f32,
    pub FontNo: ImU32,
    pub FontLoaderFlags: ::std::os::raw::c_uint,
    pub RasterizerMultiply: f32,
    pub RasterizerDensity: f32,
    pub Flags: ImFontFlags,
    pub DstFont: *mut ImFont,
    pub FontLoader: *const ImFontLoader,
    pub FontLoaderData: *mut ::std::os::raw::c_void,
}
impl Default for ImFontConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImFontGlyph {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub AdvanceX: f32,
    pub X0: f32,
    pub Y0: f32,
    pub X1: f32,
    pub Y1: f32,
    pub U0: f32,
    pub V0: f32,
    pub U1: f32,
    pub V1: f32,
    pub PackId: ::std::os::raw::c_int,
}
impl ImFontGlyph {
    #[inline]
    pub fn Colored(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Colored(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Colored_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Colored_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Visible(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Visible(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Visible_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Visible_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SourceIdx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SourceIdx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SourceIdx_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SourceIdx_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Codepoint(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Codepoint(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Codepoint_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Codepoint_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Colored: ::std::os::raw::c_uint,
        Visible: ::std::os::raw::c_uint,
        SourceIdx: ::std::os::raw::c_uint,
        Codepoint: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Colored: u32 = unsafe { ::std::mem::transmute(Colored) };
            Colored as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Visible: u32 = unsafe { ::std::mem::transmute(Visible) };
            Visible as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let SourceIdx: u32 = unsafe { ::std::mem::transmute(SourceIdx) };
            SourceIdx as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Codepoint: u32 = unsafe { ::std::mem::transmute(Codepoint) };
            Codepoint as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ImFontAtlasRectId = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImFont,
}
impl Default for ImVector_ImFontPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontConfig {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontConfig,
}
impl Default for ImVector_ImFontConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawListSharedDataPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImDrawListSharedData,
}
impl Default for ImVector_ImDrawListSharedDataPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImFontAtlas {
    pub Flags: ImFontAtlasFlags,
    pub TexDesiredFormat: ImTextureFormat,
    pub TexGlyphPadding: ::std::os::raw::c_int,
    pub TexMinWidth: ::std::os::raw::c_int,
    pub TexMinHeight: ::std::os::raw::c_int,
    pub TexMaxWidth: ::std::os::raw::c_int,
    pub TexMaxHeight: ::std::os::raw::c_int,
    pub UserData: *mut ::std::os::raw::c_void,
    pub TexRef: ImTextureRef,
    pub TexData: *mut ImTextureData,
    pub TexList: ImVector_ImTextureDataPtr,
    pub Locked: bool,
    pub RendererHasTextures: bool,
    pub TexIsBuilt: bool,
    pub TexPixelsUseColors: bool,
    pub TexUvScale: ImVec2,
    pub TexUvWhitePixel: ImVec2,
    pub Fonts: ImVector_ImFontPtr,
    pub Sources: ImVector_ImFontConfig,
    pub TexUvLines: [ImVec4; 33usize],
    pub TexNextUniqueID: ::std::os::raw::c_int,
    pub FontNextUniqueID: ::std::os::raw::c_int,
    pub DrawListSharedDatas: ImVector_ImDrawListSharedDataPtr,
    pub Builder: *mut ImFontAtlasBuilder,
    pub FontLoader: *const ImFontLoader,
    pub FontLoaderName: *const ::std::os::raw::c_char,
    pub FontLoaderData: *mut ::std::os::raw::c_void,
    pub FontLoaderFlags: ::std::os::raw::c_uint,
    pub RefCount: ::std::os::raw::c_int,
    pub OwnerContext: *mut ImGuiContext,
}
impl Default for ImFontAtlas {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_float {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut f32,
}
impl Default for ImVector_float {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImU16 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImU16,
}
impl Default for ImVector_ImU16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontGlyph {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontGlyph,
}
impl Default for ImVector_ImFontGlyph {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImFontBaked {
    pub IndexAdvanceX: ImVector_float,
    pub FallbackAdvanceX: f32,
    pub Size: f32,
    pub RasterizerDensity: f32,
    pub IndexLookup: ImVector_ImU16,
    pub Glyphs: ImVector_ImFontGlyph,
    pub FallbackGlyphIndex: ::std::os::raw::c_int,
    pub Ascent: f32,
    pub Descent: f32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub LastUsedFrame: ::std::os::raw::c_int,
    pub BakedId: ImGuiID,
    pub ContainerFont: *mut ImFont,
    pub FontLoaderDatas: *mut ::std::os::raw::c_void,
}
impl Default for ImFontBaked {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImFontBaked {
    #[inline]
    pub fn MetricsTotalSurface(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_MetricsTotalSurface(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MetricsTotalSurface_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MetricsTotalSurface_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantDestroy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WantDestroy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantDestroy_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WantDestroy_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LoadNoFallback(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadNoFallback(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadNoFallback_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LoadNoFallback_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LoadNoRenderOnLayout(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadNoRenderOnLayout(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadNoRenderOnLayout_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LoadNoRenderOnLayout_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MetricsTotalSurface: ::std::os::raw::c_uint,
        WantDestroy: ::std::os::raw::c_uint,
        LoadNoFallback: ::std::os::raw::c_uint,
        LoadNoRenderOnLayout: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let MetricsTotalSurface: u32 = unsafe { ::std::mem::transmute(MetricsTotalSurface) };
            MetricsTotalSurface as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let WantDestroy: u32 = unsafe { ::std::mem::transmute(WantDestroy) };
            WantDestroy as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let LoadNoFallback: u32 = unsafe { ::std::mem::transmute(LoadNoFallback) };
            LoadNoFallback as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let LoadNoRenderOnLayout: u32 = unsafe { ::std::mem::transmute(LoadNoRenderOnLayout) };
            LoadNoRenderOnLayout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontConfigPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImFontConfig,
}
impl Default for ImVector_ImFontConfigPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImFont {
    pub LastBaked: *mut ImFontBaked,
    pub ContainerAtlas: *mut ImFontAtlas,
    pub Flags: ImFontFlags,
    pub CurrentRasterizerDensity: f32,
    pub FontId: ImGuiID,
    pub LegacySize: f32,
    pub Sources: ImVector_ImFontConfigPtr,
    pub EllipsisChar: ImWchar,
    pub FallbackChar: ImWchar,
    pub Used8kPagesMap: [ImU8; 1usize],
    pub EllipsisAutoBake: bool,
    pub RemapPairs: ImGuiStorage,
}
impl Default for ImFont {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiViewport {
    pub ID: ImGuiID,
    pub Flags: ImGuiViewportFlags,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub FramebufferScale: ImVec2,
    pub WorkPos: ImVec2,
    pub WorkSize: ImVec2,
    pub DpiScale: f32,
    pub ParentViewportId: ImGuiID,
    pub ParentViewport: *mut ImGuiViewport,
    pub DrawData: *mut ImDrawData,
    pub RendererUserData: *mut ::std::os::raw::c_void,
    pub PlatformUserData: *mut ::std::os::raw::c_void,
    pub PlatformHandle: *mut ::std::os::raw::c_void,
    pub PlatformHandleRaw: *mut ::std::os::raw::c_void,
    pub PlatformWindowCreated: bool,
    pub PlatformRequestMove: bool,
    pub PlatformRequestResize: bool,
    pub PlatformRequestClose: bool,
}
impl Default for ImGuiViewport {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPlatformMonitor {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiPlatformMonitor,
}
impl Default for ImVector_ImGuiPlatformMonitor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiViewportPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImGuiViewport,
}
impl Default for ImVector_ImGuiViewportPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiPlatformIO {
    pub Platform_GetClipboardTextFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext) -> *const ::std::os::raw::c_char,
    >,
    pub Platform_SetClipboardTextFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, text: *const ::std::os::raw::c_char),
    >,
    pub Platform_ClipboardUserData: *mut ::std::os::raw::c_void,
    pub Platform_OpenInShellFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, path: *const ::std::os::raw::c_char) -> bool,
    >,
    pub Platform_OpenInShellUserData: *mut ::std::os::raw::c_void,
    pub Platform_SetImeDataFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            viewport: *mut ImGuiViewport,
            data: *mut ImGuiPlatformImeData,
        ),
    >,
    pub Platform_ImeUserData: *mut ::std::os::raw::c_void,
    pub Platform_LocaleDecimalPoint: ImWchar,
    pub Renderer_TextureMaxWidth: ::std::os::raw::c_int,
    pub Renderer_TextureMaxHeight: ::std::os::raw::c_int,
    pub Renderer_RenderState: *mut ::std::os::raw::c_void,
    pub Platform_CreateWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_DestroyWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_ShowWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_SetWindowPos:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, pos: ImVec2)>,
    pub Platform_GetWindowPos:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec2>,
    pub Platform_SetWindowSize:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, size: ImVec2)>,
    pub Platform_GetWindowSize:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec2>,
    pub Platform_GetWindowFramebufferScale:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec2>,
    pub Platform_SetWindowFocus:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_GetWindowFocus:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> bool>,
    pub Platform_GetWindowMinimized:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> bool>,
    pub Platform_SetWindowTitle: ::std::option::Option<
        unsafe extern "C" fn(vp: *mut ImGuiViewport, str_: *const ::std::os::raw::c_char),
    >,
    pub Platform_SetWindowAlpha:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, alpha: f32)>,
    pub Platform_UpdateWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_RenderWindow: ::std::option::Option<
        unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut ::std::os::raw::c_void),
    >,
    pub Platform_SwapBuffers: ::std::option::Option<
        unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut ::std::os::raw::c_void),
    >,
    pub Platform_GetWindowDpiScale:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> f32>,
    pub Platform_OnChangedViewport:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_GetWindowWorkAreaInsets:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec4>,
    pub Platform_CreateVkSurface: ::std::option::Option<
        unsafe extern "C" fn(
            vp: *mut ImGuiViewport,
            vk_inst: ImU64,
            vk_allocators: *const ::std::os::raw::c_void,
            out_vk_surface: *mut ImU64,
        ) -> ::std::os::raw::c_int,
    >,
    pub Renderer_CreateWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Renderer_DestroyWindow: ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Renderer_SetWindowSize:
        ::std::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, size: ImVec2)>,
    pub Renderer_RenderWindow: ::std::option::Option<
        unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut ::std::os::raw::c_void),
    >,
    pub Renderer_SwapBuffers: ::std::option::Option<
        unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut ::std::os::raw::c_void),
    >,
    pub Monitors: ImVector_ImGuiPlatformMonitor,
    pub Textures: ImVector_ImTextureDataPtr,
    pub Viewports: ImVector_ImGuiViewportPtr,
}
impl Default for ImGuiPlatformIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiPlatformMonitor {
    pub MainPos: ImVec2,
    pub MainSize: ImVec2,
    pub WorkPos: ImVec2,
    pub WorkSize: ImVec2,
    pub DpiScale: f32,
    pub PlatformHandle: *mut ::std::os::raw::c_void,
}
impl Default for ImGuiPlatformMonitor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiPlatformImeData {
    pub WantVisible: bool,
    pub WantTextInput: bool,
    pub InputPos: ImVec2,
    pub InputLineHeight: f32,
    pub ViewportId: ImGuiID,
}
impl Default for ImGuiPlatformImeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiDataAuthority = ::std::os::raw::c_int;
pub type ImGuiLayoutType = ::std::os::raw::c_int;
pub type ImGuiActivateFlags = ::std::os::raw::c_int;
pub type ImGuiDebugLogFlags = ::std::os::raw::c_int;
pub type ImGuiItemStatusFlags = ::std::os::raw::c_int;
pub type ImGuiOldColumnFlags = ::std::os::raw::c_int;
pub type ImGuiLogFlags = ::std::os::raw::c_int;
pub type ImGuiNavMoveFlags = ::std::os::raw::c_int;
pub type ImGuiNextItemDataFlags = ::std::os::raw::c_int;
pub type ImGuiNextWindowDataFlags = ::std::os::raw::c_int;
pub type ImGuiScrollFlags = ::std::os::raw::c_int;
pub type ImGuiTypingSelectFlags = ::std::os::raw::c_int;
pub type ImGuiWindowRefreshFlags = ::std::os::raw::c_int;
pub type ImGuiTableColumnIdx = ImS16;
pub type ImGuiTableDrawChannelIdx = ImU16;
pub type ImFileHandle = *mut FILE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImVec1 {
    pub x: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVec2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVec2ih {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[repr(C)]
pub struct ImRect {
    pub Min: ImVec2,
    pub Max: ImVec2,
}
impl Default for ImRect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImBitArrayPtr = *mut ImU32;
pub type ImPoolIdx = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_int {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_int,
}
impl Default for ImVector_int {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextIndex {
    pub Offsets: ImVector_int,
    pub EndOffset: ::std::os::raw::c_int,
}
impl Default for ImGuiTextIndex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImDrawListSharedData {
    pub TexUvWhitePixel: ImVec2,
    pub TexUvLines: *const ImVec4,
    pub FontAtlas: *mut ImFontAtlas,
    pub Font: *mut ImFont,
    pub FontSize: f32,
    pub FontScale: f32,
    pub CurveTessellationTol: f32,
    pub CircleSegmentMaxError: f32,
    pub InitialFringeScale: f32,
    pub InitialFlags: ImDrawListFlags,
    pub ClipRectFullscreen: ImVec4,
    pub TempBuffer: ImVector_ImVec2,
    pub DrawLists: ImVector_ImDrawListPtr,
    pub Context: *mut ImGuiContext,
    pub ArcFastVtx: [ImVec2; 48usize],
    pub ArcFastRadiusCutoff: f32,
    pub CircleSegmentCounts: [ImU8; 64usize],
}
impl Default for ImDrawListSharedData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawDataBuilder {
    pub Layers: [*mut ImVector_ImDrawListPtr; 2usize],
    pub LayerData1: ImVector_ImDrawListPtr,
}
impl Default for ImDrawDataBuilder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImFontStackData {
    pub Font: *mut ImFont,
    pub FontSizeBeforeScaling: f32,
    pub FontSizeAfterScaling: f32,
}
impl Default for ImFontStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiColorMod {
    pub Col: ImGuiCol,
    pub BackupValue: ImVec4,
}
impl Default for ImGuiColorMod {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStyleMod {
    pub VarIdx: ImGuiStyleVar,
    pub __bindgen_anon_1: ImGuiStyleMod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStyleMod__bindgen_ty_1 {
    pub BackupInt: [::std::os::raw::c_int; 2usize],
    pub BackupFloat: [f32; 2usize],
}
impl Default for ImGuiStyleMod__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ImGuiStyleMod {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDataTypeStorage {
    pub Data: [ImU8; 8usize],
}
pub const ImGuiAxis_None: ImGuiAxis = -1;
pub const ImGuiAxis_X: ImGuiAxis = 0;
pub const ImGuiAxis_Y: ImGuiAxis = 1;
pub type ImGuiAxis = ::std::os::raw::c_int;
#[repr(C)]
pub struct ImGuiComboPreviewData {
    pub PreviewRect: ImRect,
    pub BackupCursorPos: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub BackupCursorPosPrevLine: ImVec2,
    pub BackupPrevLineTextBaseOffset: f32,
    pub BackupLayout: ImGuiLayoutType,
}
impl Default for ImGuiComboPreviewData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiGroupData {
    pub WindowID: ImGuiID,
    pub BackupCursorPos: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub BackupCursorPosPrevLine: ImVec2,
    pub BackupIndent: ImVec1,
    pub BackupGroupOffset: ImVec1,
    pub BackupCurrLineSize: ImVec2,
    pub BackupCurrLineTextBaseOffset: f32,
    pub BackupActiveIdIsAlive: ImGuiID,
    pub BackupDeactivatedIdIsAlive: bool,
    pub BackupHoveredIdIsAlive: bool,
    pub BackupIsSameLine: bool,
    pub EmitItem: bool,
}
impl Default for ImGuiGroupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiMenuColumns {
    pub TotalWidth: ImU32,
    pub NextTotalWidth: ImU32,
    pub Spacing: ImU16,
    pub OffsetIcon: ImU16,
    pub OffsetLabel: ImU16,
    pub OffsetShortcut: ImU16,
    pub OffsetMark: ImU16,
    pub Widths: [ImU16; 4usize],
}
#[repr(C)]
pub struct ImGuiInputTextDeactivatedState {
    pub ID: ImGuiID,
    pub TextA: ImVector_char,
}
impl Default for ImGuiInputTextDeactivatedState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImStbTexteditState = STB_TexteditState;
#[repr(C)]
pub struct ImGuiInputTextState {
    pub Ctx: *mut ImGuiContext,
    pub Stb: *mut ImStbTexteditState,
    pub Flags: ImGuiInputTextFlags,
    pub ID: ImGuiID,
    pub TextLen: ::std::os::raw::c_int,
    pub TextSrc: *const ::std::os::raw::c_char,
    pub TextA: ImVector_char,
    pub TextToRevertTo: ImVector_char,
    pub CallbackTextBackup: ImVector_char,
    pub BufCapacity: ::std::os::raw::c_int,
    pub Scroll: ImVec2,
    pub LineCount: ::std::os::raw::c_int,
    pub WrapWidth: f32,
    pub CursorAnim: f32,
    pub CursorFollow: bool,
    pub CursorCenterY: bool,
    pub SelectedAllMouseLock: bool,
    pub Edited: bool,
    pub WantReloadUserBuf: bool,
    pub LastMoveDirectionLR: ImS8,
    pub ReloadSelectionStart: ::std::os::raw::c_int,
    pub ReloadSelectionEnd: ::std::os::raw::c_int,
}
impl Default for ImGuiInputTextState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiNextWindowData {
    pub HasFlags: ImGuiNextWindowDataFlags,
    pub PosCond: ImGuiCond,
    pub SizeCond: ImGuiCond,
    pub CollapsedCond: ImGuiCond,
    pub DockCond: ImGuiCond,
    pub PosVal: ImVec2,
    pub PosPivotVal: ImVec2,
    pub SizeVal: ImVec2,
    pub ContentSizeVal: ImVec2,
    pub ScrollVal: ImVec2,
    pub WindowFlags: ImGuiWindowFlags,
    pub ChildFlags: ImGuiChildFlags,
    pub PosUndock: bool,
    pub CollapsedVal: bool,
    pub SizeConstraintRect: ImRect,
    pub SizeCallback: ImGuiSizeCallback,
    pub SizeCallbackUserData: *mut ::std::os::raw::c_void,
    pub BgAlphaVal: f32,
    pub ViewportId: ImGuiID,
    pub DockId: ImGuiID,
    pub WindowClass: ImGuiWindowClass,
    pub MenuBarOffsetMinVal: ImVec2,
    pub RefreshFlagsVal: ImGuiWindowRefreshFlags,
}
impl Default for ImGuiNextWindowData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiNextItemData {
    pub HasFlags: ImGuiNextItemDataFlags,
    pub ItemFlags: ImGuiItemFlags,
    pub FocusScopeId: ImGuiID,
    pub SelectionUserData: ImGuiSelectionUserData,
    pub Width: f32,
    pub Shortcut: ImGuiKeyChord,
    pub ShortcutFlags: ImGuiInputFlags,
    pub OpenVal: bool,
    pub OpenCond: ImU8,
    pub RefVal: ImGuiDataTypeStorage,
    pub StorageId: ImGuiID,
}
impl Default for ImGuiNextItemData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiLastItemData {
    pub ID: ImGuiID,
    pub ItemFlags: ImGuiItemFlags,
    pub StatusFlags: ImGuiItemStatusFlags,
    pub Rect: ImRect,
    pub NavRect: ImRect,
    pub DisplayRect: ImRect,
    pub ClipRect: ImRect,
    pub Shortcut: ImGuiKeyChord,
}
impl Default for ImGuiLastItemData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTreeNodeStackData {
    pub ID: ImGuiID,
    pub TreeFlags: ImGuiTreeNodeFlags,
    pub ItemFlags: ImGuiItemFlags,
    pub NavRect: ImRect,
    pub DrawLinesX1: f32,
    pub DrawLinesToNodesY2: f32,
    pub DrawLinesTableColumn: ImGuiTableColumnIdx,
}
impl Default for ImGuiTreeNodeStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiErrorRecoveryState {
    pub SizeOfWindowStack: ::std::os::raw::c_short,
    pub SizeOfIDStack: ::std::os::raw::c_short,
    pub SizeOfTreeStack: ::std::os::raw::c_short,
    pub SizeOfColorStack: ::std::os::raw::c_short,
    pub SizeOfStyleVarStack: ::std::os::raw::c_short,
    pub SizeOfFontStack: ::std::os::raw::c_short,
    pub SizeOfFocusScopeStack: ::std::os::raw::c_short,
    pub SizeOfGroupStack: ::std::os::raw::c_short,
    pub SizeOfItemFlagsStack: ::std::os::raw::c_short,
    pub SizeOfBeginPopupStack: ::std::os::raw::c_short,
    pub SizeOfDisabledStack: ::std::os::raw::c_short,
}
#[repr(C)]
pub struct ImGuiWindowStackData {
    pub Window: *mut ImGuiWindow,
    pub ParentLastItemDataBackup: ImGuiLastItemData,
    pub StackSizesInBegin: ImGuiErrorRecoveryState,
    pub DisabledOverrideReenable: bool,
    pub DisabledOverrideReenableAlphaBackup: f32,
}
impl Default for ImGuiWindowStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiShrinkWidthItem {
    pub Index: ::std::os::raw::c_int,
    pub Width: f32,
    pub InitialWidth: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiPtrOrIndex {
    pub Ptr: *mut ::std::os::raw::c_void,
    pub Index: ::std::os::raw::c_int,
}
impl Default for ImGuiPtrOrIndex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiDeactivatedItemData {
    pub ID: ImGuiID,
    pub ElapseFrame: ::std::os::raw::c_int,
    pub HasBeenEditedBefore: bool,
    pub IsAlive: bool,
}
impl Default for ImGuiDeactivatedItemData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiPopupData {
    pub PopupId: ImGuiID,
    pub Window: *mut ImGuiWindow,
    pub RestoreNavWindow: *mut ImGuiWindow,
    pub ParentNavLayer: ::std::os::raw::c_int,
    pub OpenFrameCount: ::std::os::raw::c_int,
    pub OpenParentId: ImGuiID,
    pub OpenPopupPos: ImVec2,
    pub OpenMousePos: ImVec2,
}
impl Default for ImGuiPopupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN {
    pub Storage: [ImU32; 5usize],
}
pub type ImBitArrayForNamedKeys = ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN;
pub const ImGuiInputEventType_None: ImGuiInputEventType = 0;
pub const ImGuiInputEventType_MousePos: ImGuiInputEventType = 1;
pub const ImGuiInputEventType_MouseWheel: ImGuiInputEventType = 2;
pub const ImGuiInputEventType_MouseButton: ImGuiInputEventType = 3;
pub const ImGuiInputEventType_MouseViewport: ImGuiInputEventType = 4;
pub const ImGuiInputEventType_Key: ImGuiInputEventType = 5;
pub const ImGuiInputEventType_Text: ImGuiInputEventType = 6;
pub const ImGuiInputEventType_Focus: ImGuiInputEventType = 7;
pub const ImGuiInputEventType_COUNT: ImGuiInputEventType = 8;
pub type ImGuiInputEventType = ::std::os::raw::c_uint;
pub const ImGuiInputSource_None: ImGuiInputSource = 0;
pub const ImGuiInputSource_Mouse: ImGuiInputSource = 1;
pub const ImGuiInputSource_Keyboard: ImGuiInputSource = 2;
pub const ImGuiInputSource_Gamepad: ImGuiInputSource = 3;
pub const ImGuiInputSource_COUNT: ImGuiInputSource = 4;
pub type ImGuiInputSource = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventMousePos {
    pub PosX: f32,
    pub PosY: f32,
    pub MouseSource: ImGuiMouseSource,
}
impl Default for ImGuiInputEventMousePos {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventMouseWheel {
    pub WheelX: f32,
    pub WheelY: f32,
    pub MouseSource: ImGuiMouseSource,
}
impl Default for ImGuiInputEventMouseWheel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventMouseButton {
    pub Button: ::std::os::raw::c_int,
    pub Down: bool,
    pub MouseSource: ImGuiMouseSource,
}
impl Default for ImGuiInputEventMouseButton {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiInputEventMouseViewport {
    pub HoveredViewportID: ImGuiID,
}
impl Default for ImGuiInputEventMouseViewport {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventKey {
    pub Key: ImGuiKey,
    pub Down: bool,
    pub AnalogValue: f32,
}
impl Default for ImGuiInputEventKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventText {
    pub Char: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventAppFocused {
    pub Focused: bool,
}
#[repr(C)]
pub struct ImGuiInputEvent {
    pub Type: ImGuiInputEventType,
    pub Source: ImGuiInputSource,
    pub EventId: ImU32,
    pub __bindgen_anon_1: ImGuiInputEvent__bindgen_ty_1,
    pub AddedByTestEngine: bool,
}
#[repr(C)]
pub struct ImGuiInputEvent__bindgen_ty_1 {
    pub MousePos: __BindgenUnionField<ImGuiInputEventMousePos>,
    pub MouseWheel: __BindgenUnionField<ImGuiInputEventMouseWheel>,
    pub MouseButton: __BindgenUnionField<ImGuiInputEventMouseButton>,
    pub MouseViewport: __BindgenUnionField<ImGuiInputEventMouseViewport>,
    pub Key: __BindgenUnionField<ImGuiInputEventKey>,
    pub Text: __BindgenUnionField<ImGuiInputEventText>,
    pub AppFocused: __BindgenUnionField<ImGuiInputEventAppFocused>,
    pub bindgen_union_field: [u32; 3usize],
}
impl Default for ImGuiInputEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ImGuiInputEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiKeyRoutingIndex = ImS16;
#[repr(C)]
pub struct ImGuiKeyRoutingData {
    pub NextEntryIndex: ImGuiKeyRoutingIndex,
    pub Mods: ImU16,
    pub RoutingCurrScore: ImU16,
    pub RoutingNextScore: ImU16,
    pub RoutingCurr: ImGuiID,
    pub RoutingNext: ImGuiID,
}
impl Default for ImGuiKeyRoutingData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiKeyRoutingData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiKeyRoutingData,
}
impl Default for ImVector_ImGuiKeyRoutingData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiKeyRoutingTable {
    pub Index: [ImGuiKeyRoutingIndex; 155usize],
    pub Entries: ImVector_ImGuiKeyRoutingData,
    pub EntriesNext: ImVector_ImGuiKeyRoutingData,
}
impl Default for ImGuiKeyRoutingTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiKeyOwnerData {
    pub OwnerCurr: ImGuiID,
    pub OwnerNext: ImGuiID,
    pub LockThisFrame: bool,
    pub LockUntilRelease: bool,
}
impl Default for ImGuiKeyOwnerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiListClipperRange {
    pub Min: ::std::os::raw::c_int,
    pub Max: ::std::os::raw::c_int,
    pub PosToIndexConvert: bool,
    pub PosToIndexOffsetMin: ImS8,
    pub PosToIndexOffsetMax: ImS8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiListClipperRange {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiListClipperRange,
}
impl Default for ImVector_ImGuiListClipperRange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiListClipperData {
    pub ListClipper: *mut ImGuiListClipper,
    pub LossynessOffset: f32,
    pub StepNo: ::std::os::raw::c_int,
    pub ItemsFrozen: ::std::os::raw::c_int,
    pub Ranges: ImVector_ImGuiListClipperRange,
}
impl Default for ImGuiListClipperData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiNavLayer_Main: ImGuiNavLayer = 0;
pub const ImGuiNavLayer_Menu: ImGuiNavLayer = 1;
pub const ImGuiNavLayer_COUNT: ImGuiNavLayer = 2;
pub type ImGuiNavLayer = ::std::os::raw::c_uint;
#[repr(C)]
pub struct ImGuiNavItemData {
    pub Window: *mut ImGuiWindow,
    pub ID: ImGuiID,
    pub FocusScopeId: ImGuiID,
    pub RectRel: ImRect,
    pub ItemFlags: ImGuiItemFlags,
    pub DistBox: f32,
    pub DistCenter: f32,
    pub DistAxial: f32,
    pub SelectionUserData: ImGuiSelectionUserData,
}
impl Default for ImGuiNavItemData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiFocusScopeData {
    pub ID: ImGuiID,
    pub WindowID: ImGuiID,
}
impl Default for ImGuiFocusScopeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTypingSelectRequest {
    pub Flags: ImGuiTypingSelectFlags,
    pub SearchBufferLen: ::std::os::raw::c_int,
    pub SearchBuffer: *const ::std::os::raw::c_char,
    pub SelectRequest: bool,
    pub SingleCharMode: bool,
    pub SingleCharSize: ImS8,
}
impl Default for ImGuiTypingSelectRequest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTypingSelectState {
    pub Request: ImGuiTypingSelectRequest,
    pub SearchBuffer: [::std::os::raw::c_char; 64usize],
    pub FocusScope: ImGuiID,
    pub LastRequestFrame: ::std::os::raw::c_int,
    pub LastRequestTime: f32,
    pub SingleCharModeLock: bool,
}
impl Default for ImGuiTypingSelectState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiOldColumnData {
    pub OffsetNorm: f32,
    pub OffsetNormBeforeResize: f32,
    pub Flags: ImGuiOldColumnFlags,
    pub ClipRect: ImRect,
}
impl Default for ImGuiOldColumnData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiOldColumnData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiOldColumnData,
}
impl Default for ImVector_ImGuiOldColumnData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiOldColumns {
    pub ID: ImGuiID,
    pub Flags: ImGuiOldColumnFlags,
    pub IsFirstFrame: bool,
    pub IsBeingResized: bool,
    pub Current: ::std::os::raw::c_int,
    pub Count: ::std::os::raw::c_int,
    pub OffMinX: f32,
    pub OffMaxX: f32,
    pub LineMinY: f32,
    pub LineMaxY: f32,
    pub HostCursorPosY: f32,
    pub HostCursorMaxPosX: f32,
    pub HostInitialClipRect: ImRect,
    pub HostBackupClipRect: ImRect,
    pub HostBackupParentWorkRect: ImRect,
    pub Columns: ImVector_ImGuiOldColumnData,
    pub Splitter: ImDrawListSplitter,
}
impl Default for ImGuiOldColumns {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiBoxSelectState {
    pub ID: ImGuiID,
    pub IsActive: bool,
    pub IsStarting: bool,
    pub IsStartedFromVoid: bool,
    pub IsStartedSetNavIdOnce: bool,
    pub RequestClear: bool,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub StartPosRel: ImVec2,
    pub EndPosRel: ImVec2,
    pub ScrollAccum: ImVec2,
    pub Window: *mut ImGuiWindow,
    pub UnclipMode: bool,
    pub UnclipRect: ImRect,
    pub BoxSelectRectPrev: ImRect,
    pub BoxSelectRectCurr: ImRect,
}
impl Default for ImGuiBoxSelectState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiBoxSelectState {
    #[inline]
    pub fn KeyMods(&self) -> ImGuiKeyChord {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_KeyMods(&mut self, val: ImGuiKeyChord) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KeyMods_raw(this: *const Self) -> ImGuiKeyChord {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KeyMods_raw(this: *mut Self, val: ImGuiKeyChord) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(KeyMods: ImGuiKeyChord) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let KeyMods: u32 = unsafe { ::std::mem::transmute(KeyMods) };
            KeyMods as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ImGuiMultiSelectTempData {
    pub IO: ImGuiMultiSelectIO,
    pub Storage: *mut ImGuiMultiSelectState,
    pub FocusScopeId: ImGuiID,
    pub Flags: ImGuiMultiSelectFlags,
    pub ScopeRectMin: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub LastSubmittedItem: ImGuiSelectionUserData,
    pub BoxSelectId: ImGuiID,
    pub KeyMods: ImGuiKeyChord,
    pub LoopRequestSetAll: ImS8,
    pub IsEndIO: bool,
    pub IsFocused: bool,
    pub IsKeyboardSetRange: bool,
    pub NavIdPassedBy: bool,
    pub RangeSrcPassedBy: bool,
    pub RangeDstPassedBy: bool,
}
impl Default for ImGuiMultiSelectTempData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiMultiSelectState {
    pub Window: *mut ImGuiWindow,
    pub ID: ImGuiID,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub LastSelectionSize: ::std::os::raw::c_int,
    pub RangeSelected: ImS8,
    pub NavIdSelected: ImS8,
    pub RangeSrcItem: ImGuiSelectionUserData,
    pub NavIdItem: ImGuiSelectionUserData,
}
impl Default for ImGuiMultiSelectState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiDockNodeState_Unknown: ImGuiDockNodeState = 0;
pub const ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow: ImGuiDockNodeState = 1;
pub const ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing: ImGuiDockNodeState = 2;
pub const ImGuiDockNodeState_HostWindowVisible: ImGuiDockNodeState = 3;
pub type ImGuiDockNodeState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiWindowPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImGuiWindow,
}
impl Default for ImVector_ImGuiWindowPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiDockNode {
    pub ID: ImGuiID,
    pub SharedFlags: ImGuiDockNodeFlags,
    pub LocalFlags: ImGuiDockNodeFlags,
    pub LocalFlagsInWindows: ImGuiDockNodeFlags,
    pub MergedFlags: ImGuiDockNodeFlags,
    pub State: ImGuiDockNodeState,
    pub ParentNode: *mut ImGuiDockNode,
    pub ChildNodes: [*mut ImGuiDockNode; 2usize],
    pub Windows: ImVector_ImGuiWindowPtr,
    pub TabBar: *mut ImGuiTabBar,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub SizeRef: ImVec2,
    pub SplitAxis: ImGuiAxis,
    pub WindowClass: ImGuiWindowClass,
    pub LastBgColor: ImU32,
    pub HostWindow: *mut ImGuiWindow,
    pub VisibleWindow: *mut ImGuiWindow,
    pub CentralNode: *mut ImGuiDockNode,
    pub OnlyNodeWithWindows: *mut ImGuiDockNode,
    pub CountNodeWithWindows: ::std::os::raw::c_int,
    pub LastFrameAlive: ::std::os::raw::c_int,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub LastFrameFocused: ::std::os::raw::c_int,
    pub LastFocusedNodeId: ImGuiID,
    pub SelectedTabId: ImGuiID,
    pub WantCloseTabId: ImGuiID,
    pub RefViewportId: ImGuiID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl Default for ImGuiDockNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiDockNode {
    #[inline]
    pub fn AuthorityForPos(&self) -> ImGuiDataAuthority {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForPos(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuthorityForPos_raw(this: *const Self) -> ImGuiDataAuthority {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuthorityForPos_raw(this: *mut Self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuthorityForSize(&self) -> ImGuiDataAuthority {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForSize(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuthorityForSize_raw(this: *const Self) -> ImGuiDataAuthority {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuthorityForSize_raw(this: *mut Self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuthorityForViewport(&self) -> ImGuiDataAuthority {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForViewport(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuthorityForViewport_raw(this: *const Self) -> ImGuiDataAuthority {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuthorityForViewport_raw(this: *mut Self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsVisible(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsVisible_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IsVisible_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsFocused(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsFocused(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsFocused_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IsFocused_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsBgDrawnThisFrame(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsBgDrawnThisFrame(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsBgDrawnThisFrame_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IsBgDrawnThisFrame_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HasCloseButton(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasCloseButton(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HasCloseButton_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_HasCloseButton_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HasWindowMenuButton(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasWindowMenuButton(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HasWindowMenuButton_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_HasWindowMenuButton_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HasCentralNodeChild(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasCentralNodeChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HasCentralNodeChild_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_HasCentralNodeChild_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantCloseAll(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantCloseAll(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantCloseAll_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WantCloseAll_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantLockSizeOnce(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantLockSizeOnce(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantLockSizeOnce_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WantLockSizeOnce_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantMouseMove(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantMouseMove(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantMouseMove_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WantMouseMove_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantHiddenTabBarUpdate(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantHiddenTabBarUpdate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantHiddenTabBarUpdate_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WantHiddenTabBarUpdate_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WantHiddenTabBarToggle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantHiddenTabBarToggle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WantHiddenTabBarToggle_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WantHiddenTabBarToggle_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AuthorityForPos: ImGuiDataAuthority,
        AuthorityForSize: ImGuiDataAuthority,
        AuthorityForViewport: ImGuiDataAuthority,
        IsVisible: bool,
        IsFocused: bool,
        IsBgDrawnThisFrame: bool,
        HasCloseButton: bool,
        HasWindowMenuButton: bool,
        HasCentralNodeChild: bool,
        WantCloseAll: bool,
        WantLockSizeOnce: bool,
        WantMouseMove: bool,
        WantHiddenTabBarUpdate: bool,
        WantHiddenTabBarToggle: bool,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let AuthorityForPos: u32 = unsafe { ::std::mem::transmute(AuthorityForPos) };
            AuthorityForPos as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let AuthorityForSize: u32 = unsafe { ::std::mem::transmute(AuthorityForSize) };
            AuthorityForSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let AuthorityForViewport: u32 = unsafe { ::std::mem::transmute(AuthorityForViewport) };
            AuthorityForViewport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IsVisible: u8 = unsafe { ::std::mem::transmute(IsVisible) };
            IsVisible as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IsFocused: u8 = unsafe { ::std::mem::transmute(IsFocused) };
            IsFocused as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let IsBgDrawnThisFrame: u8 = unsafe { ::std::mem::transmute(IsBgDrawnThisFrame) };
            IsBgDrawnThisFrame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let HasCloseButton: u8 = unsafe { ::std::mem::transmute(HasCloseButton) };
            HasCloseButton as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let HasWindowMenuButton: u8 = unsafe { ::std::mem::transmute(HasWindowMenuButton) };
            HasWindowMenuButton as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HasCentralNodeChild: u8 = unsafe { ::std::mem::transmute(HasCentralNodeChild) };
            HasCentralNodeChild as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WantCloseAll: u8 = unsafe { ::std::mem::transmute(WantCloseAll) };
            WantCloseAll as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WantLockSizeOnce: u8 = unsafe { ::std::mem::transmute(WantLockSizeOnce) };
            WantLockSizeOnce as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let WantMouseMove: u8 = unsafe { ::std::mem::transmute(WantMouseMove) };
            WantMouseMove as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let WantHiddenTabBarUpdate: u8 =
                unsafe { ::std::mem::transmute(WantHiddenTabBarUpdate) };
            WantHiddenTabBarUpdate as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WantHiddenTabBarToggle: u8 =
                unsafe { ::std::mem::transmute(WantHiddenTabBarToggle) };
            WantHiddenTabBarToggle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiWindowDockStyle {
    pub Colors: [ImU32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiDockRequest {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiDockRequest,
}
impl Default for ImVector_ImGuiDockRequest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiDockNodeSettings {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiDockNodeSettings,
}
impl Default for ImVector_ImGuiDockNodeSettings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDockContext {
    pub Nodes: ImGuiStorage,
    pub Requests: ImVector_ImGuiDockRequest,
    pub NodesSettings: ImVector_ImGuiDockNodeSettings,
    pub WantFullRebuild: bool,
}
impl Default for ImGuiDockContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiViewportP {
    pub _ImGuiViewport: ImGuiViewport,
    pub Window: *mut ImGuiWindow,
    pub Idx: ::std::os::raw::c_int,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub LastFocusedStampCount: ::std::os::raw::c_int,
    pub LastNameHash: ImGuiID,
    pub LastPos: ImVec2,
    pub LastSize: ImVec2,
    pub Alpha: f32,
    pub LastAlpha: f32,
    pub LastFocusedHadNavWindow: bool,
    pub PlatformMonitor: ::std::os::raw::c_short,
    pub BgFgDrawListsLastFrame: [::std::os::raw::c_int; 2usize],
    pub BgFgDrawLists: [*mut ImDrawList; 2usize],
    pub DrawDataP: ImDrawData,
    pub DrawDataBuilder: ImDrawDataBuilder,
    pub LastPlatformPos: ImVec2,
    pub LastPlatformSize: ImVec2,
    pub LastRendererSize: ImVec2,
    pub WorkInsetMin: ImVec2,
    pub WorkInsetMax: ImVec2,
    pub BuildWorkInsetMin: ImVec2,
    pub BuildWorkInsetMax: ImVec2,
}
impl Default for ImGuiViewportP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiSettingsHandler {
    pub TypeName: *const ::std::os::raw::c_char,
    pub TypeHash: ImGuiID,
    pub ClearAllFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler),
    >,
    pub ReadInitFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler),
    >,
    pub ReadOpenFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            name: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub ReadLineFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            entry: *mut ::std::os::raw::c_void,
            line: *const ::std::os::raw::c_char,
        ),
    >,
    pub ApplyAllFn: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler),
    >,
    pub WriteAllFn: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            out_buf: *mut ImGuiTextBuffer,
        ),
    >,
    pub UserData: *mut ::std::os::raw::c_void,
}
impl Default for ImGuiSettingsHandler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ImGuiContext,
        user_data: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDebugAllocEntry {
    pub FrameCount: ::std::os::raw::c_int,
    pub AllocCount: ImS16,
    pub FreeCount: ImS16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDebugAllocInfo {
    pub TotalAllocCount: ::std::os::raw::c_int,
    pub TotalFreeCount: ::std::os::raw::c_int,
    pub LastEntriesIdx: ImS16,
    pub LastEntriesBuf: [ImGuiDebugAllocEntry; 6usize],
}
#[repr(C)]
pub struct ImGuiMetricsConfig {
    pub ShowDebugLog: bool,
    pub ShowIDStackTool: bool,
    pub ShowWindowsRects: bool,
    pub ShowWindowsBeginOrder: bool,
    pub ShowTablesRects: bool,
    pub ShowDrawCmdMesh: bool,
    pub ShowDrawCmdBoundingBoxes: bool,
    pub ShowTextEncodingViewer: bool,
    pub ShowTextureUsedRect: bool,
    pub ShowDockingNodes: bool,
    pub ShowWindowsRectsType: ::std::os::raw::c_int,
    pub ShowTablesRectsType: ::std::os::raw::c_int,
    pub HighlightMonitorIdx: ::std::os::raw::c_int,
    pub HighlightViewportID: ImGuiID,
    pub ShowFontPreview: bool,
}
impl Default for ImGuiMetricsConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiStackLevelInfo {
    pub ID: ImGuiID,
    pub QueryFrameCount: ImS8,
    pub QuerySuccess: bool,
    pub DataType: ImS8,
    pub DescOffset: ::std::os::raw::c_int,
}
impl Default for ImGuiStackLevelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStackLevelInfo {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiStackLevelInfo,
}
impl Default for ImVector_ImGuiStackLevelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiIDStackTool {
    pub LastActiveFrame: ::std::os::raw::c_int,
    pub StackLevel: ::std::os::raw::c_int,
    pub QueryMainId: ImGuiID,
    pub Results: ImVector_ImGuiStackLevelInfo,
    pub QueryHookActive: bool,
    pub OptHexEncodeNonAsciiChars: bool,
    pub OptCopyToClipboardOnCtrlC: bool,
    pub CopyToClipboardLastTime: f32,
    pub ResultPathsBuf: ImGuiTextBuffer,
    pub ResultTempBuf: ImGuiTextBuffer,
}
impl Default for ImGuiIDStackTool {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiContextHookCallback = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ImGuiContext, hook: *mut ImGuiContextHook),
>;
pub const ImGuiContextHookType_NewFramePre: ImGuiContextHookType = 0;
pub const ImGuiContextHookType_NewFramePost: ImGuiContextHookType = 1;
pub const ImGuiContextHookType_EndFramePre: ImGuiContextHookType = 2;
pub const ImGuiContextHookType_EndFramePost: ImGuiContextHookType = 3;
pub const ImGuiContextHookType_RenderPre: ImGuiContextHookType = 4;
pub const ImGuiContextHookType_RenderPost: ImGuiContextHookType = 5;
pub const ImGuiContextHookType_Shutdown: ImGuiContextHookType = 6;
pub const ImGuiContextHookType_PendingRemoval_: ImGuiContextHookType = 7;
pub type ImGuiContextHookType = ::std::os::raw::c_uint;
#[repr(C)]
pub struct ImGuiContextHook {
    pub HookId: ImGuiID,
    pub Type: ImGuiContextHookType,
    pub Owner: ImGuiID,
    pub Callback: ImGuiContextHookCallback,
    pub UserData: *mut ::std::os::raw::c_void,
}
impl Default for ImGuiContextHook {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontAtlasPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImFontAtlas,
}
impl Default for ImVector_ImFontAtlasPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiInputEvent {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiInputEvent,
}
impl Default for ImVector_ImGuiInputEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiWindowStackData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiWindowStackData,
}
impl Default for ImVector_ImGuiWindowStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiColorMod {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiColorMod,
}
impl Default for ImVector_ImGuiColorMod {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStyleMod {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiStyleMod,
}
impl Default for ImVector_ImGuiStyleMod {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontStackData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontStackData,
}
impl Default for ImVector_ImFontStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiFocusScopeData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiFocusScopeData,
}
impl Default for ImVector_ImGuiFocusScopeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiItemFlags {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiItemFlags,
}
impl Default for ImVector_ImGuiItemFlags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiGroupData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiGroupData,
}
impl Default for ImVector_ImGuiGroupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPopupData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiPopupData,
}
impl Default for ImVector_ImGuiPopupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTreeNodeStackData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTreeNodeStackData,
}
impl Default for ImVector_ImGuiTreeNodeStackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiViewportPPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImGuiViewportP,
}
impl Default for ImVector_ImGuiViewportPPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_unsigned_char {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ::std::os::raw::c_uchar,
}
impl Default for ImVector_unsigned_char {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiListClipperData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiListClipperData,
}
impl Default for ImVector_ImGuiListClipperData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableTempData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTableTempData,
}
impl Default for ImVector_ImGuiTableTempData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTable {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTable,
}
impl Default for ImVector_ImGuiTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImPool_ImGuiTable {
    pub Buf: ImVector_ImGuiTable,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
    pub AliveCount: ImPoolIdx,
}
impl Default for ImPool_ImGuiTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTabBar {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTabBar,
}
impl Default for ImVector_ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImPool_ImGuiTabBar {
    pub Buf: ImVector_ImGuiTabBar,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
    pub AliveCount: ImPoolIdx,
}
impl Default for ImPool_ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPtrOrIndex {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiPtrOrIndex,
}
impl Default for ImVector_ImGuiPtrOrIndex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiShrinkWidthItem {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiShrinkWidthItem,
}
impl Default for ImVector_ImGuiShrinkWidthItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiMultiSelectTempData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiMultiSelectTempData,
}
impl Default for ImVector_ImGuiMultiSelectTempData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiMultiSelectState {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiMultiSelectState,
}
impl Default for ImVector_ImGuiMultiSelectState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImPool_ImGuiMultiSelectState {
    pub Buf: ImVector_ImGuiMultiSelectState,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
    pub AliveCount: ImPoolIdx,
}
impl Default for ImPool_ImGuiMultiSelectState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiID {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiID,
}
impl Default for ImVector_ImGuiID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiSettingsHandler {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiSettingsHandler,
}
impl Default for ImVector_ImGuiSettingsHandler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImChunkStream_ImGuiWindowSettings {
    pub Buf: ImVector_char,
}
impl Default for ImChunkStream_ImGuiWindowSettings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImChunkStream_ImGuiTableSettings {
    pub Buf: ImVector_char,
}
impl Default for ImChunkStream_ImGuiTableSettings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiContextHook {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiContextHook,
}
impl Default for ImVector_ImGuiContextHook {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiWindowTempData {
    pub CursorPos: ImVec2,
    pub CursorPosPrevLine: ImVec2,
    pub CursorStartPos: ImVec2,
    pub CursorMaxPos: ImVec2,
    pub IdealMaxPos: ImVec2,
    pub CurrLineSize: ImVec2,
    pub PrevLineSize: ImVec2,
    pub CurrLineTextBaseOffset: f32,
    pub PrevLineTextBaseOffset: f32,
    pub IsSameLine: bool,
    pub IsSetPos: bool,
    pub Indent: ImVec1,
    pub ColumnsOffset: ImVec1,
    pub GroupOffset: ImVec1,
    pub CursorStartPosLossyness: ImVec2,
    pub NavLayerCurrent: ImGuiNavLayer,
    pub NavLayersActiveMask: ::std::os::raw::c_short,
    pub NavLayersActiveMaskNext: ::std::os::raw::c_short,
    pub NavIsScrollPushableX: bool,
    pub NavHideHighlightOneFrame: bool,
    pub NavWindowHasScrollY: bool,
    pub MenuBarAppending: bool,
    pub MenuBarOffset: ImVec2,
    pub MenuColumns: ImGuiMenuColumns,
    pub TreeDepth: ::std::os::raw::c_int,
    pub TreeHasStackDataDepthMask: ImU32,
    pub TreeRecordsClippedNodesY2Mask: ImU32,
    pub ChildWindows: ImVector_ImGuiWindowPtr,
    pub StateStorage: *mut ImGuiStorage,
    pub CurrentColumns: *mut ImGuiOldColumns,
    pub CurrentTableIdx: ::std::os::raw::c_int,
    pub LayoutType: ImGuiLayoutType,
    pub ParentLayoutType: ImGuiLayoutType,
    pub ModalDimBgColor: ImU32,
    pub WindowItemStatusFlags: ImGuiItemStatusFlags,
    pub ChildItemStatusFlags: ImGuiItemStatusFlags,
    pub DockTabItemStatusFlags: ImGuiItemStatusFlags,
    pub DockTabItemRect: ImRect,
    pub ItemWidth: f32,
    pub TextWrapPos: f32,
    pub ItemWidthStack: ImVector_float,
    pub TextWrapPosStack: ImVector_float,
}
impl Default for ImGuiWindowTempData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiOldColumns {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiOldColumns,
}
impl Default for ImVector_ImGuiOldColumns {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiWindow {
    pub Ctx: *mut ImGuiContext,
    pub Name: *mut ::std::os::raw::c_char,
    pub ID: ImGuiID,
    pub Flags: ImGuiWindowFlags,
    pub FlagsPreviousFrame: ImGuiWindowFlags,
    pub ChildFlags: ImGuiChildFlags,
    pub WindowClass: ImGuiWindowClass,
    pub Viewport: *mut ImGuiViewportP,
    pub ViewportId: ImGuiID,
    pub ViewportPos: ImVec2,
    pub ViewportAllowPlatformMonitorExtend: ::std::os::raw::c_int,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub SizeFull: ImVec2,
    pub ContentSize: ImVec2,
    pub ContentSizeIdeal: ImVec2,
    pub ContentSizeExplicit: ImVec2,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub TitleBarHeight: f32,
    pub MenuBarHeight: f32,
    pub DecoOuterSizeX1: f32,
    pub DecoOuterSizeY1: f32,
    pub DecoOuterSizeX2: f32,
    pub DecoOuterSizeY2: f32,
    pub DecoInnerSizeX1: f32,
    pub DecoInnerSizeY1: f32,
    pub NameBufLen: ::std::os::raw::c_int,
    pub MoveId: ImGuiID,
    pub TabId: ImGuiID,
    pub ChildId: ImGuiID,
    pub PopupId: ImGuiID,
    pub Scroll: ImVec2,
    pub ScrollMax: ImVec2,
    pub ScrollTarget: ImVec2,
    pub ScrollTargetCenterRatio: ImVec2,
    pub ScrollTargetEdgeSnapDist: ImVec2,
    pub ScrollbarSizes: ImVec2,
    pub ScrollbarX: bool,
    pub ScrollbarY: bool,
    pub ScrollbarXStabilizeEnabled: bool,
    pub ScrollbarXStabilizeToggledHistory: ImU8,
    pub ViewportOwned: bool,
    pub Active: bool,
    pub WasActive: bool,
    pub WriteAccessed: bool,
    pub Collapsed: bool,
    pub WantCollapseToggle: bool,
    pub SkipItems: bool,
    pub SkipRefresh: bool,
    pub Appearing: bool,
    pub Hidden: bool,
    pub IsFallbackWindow: bool,
    pub IsExplicitChild: bool,
    pub HasCloseButton: bool,
    pub ResizeBorderHovered: ::std::os::raw::c_schar,
    pub ResizeBorderHeld: ::std::os::raw::c_schar,
    pub BeginCount: ::std::os::raw::c_short,
    pub BeginCountPreviousFrame: ::std::os::raw::c_short,
    pub BeginOrderWithinParent: ::std::os::raw::c_short,
    pub BeginOrderWithinContext: ::std::os::raw::c_short,
    pub FocusOrder: ::std::os::raw::c_short,
    pub AutoFitFramesX: ImS8,
    pub AutoFitFramesY: ImS8,
    pub AutoFitOnlyGrows: bool,
    pub AutoPosLastDirection: ImGuiDir,
    pub HiddenFramesCanSkipItems: ImS8,
    pub HiddenFramesCannotSkipItems: ImS8,
    pub HiddenFramesForRenderOnly: ImS8,
    pub DisableInputsFrames: ImS8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub SetWindowPosVal: ImVec2,
    pub SetWindowPosPivot: ImVec2,
    pub IDStack: ImVector_ImGuiID,
    pub DC: ImGuiWindowTempData,
    pub OuterRectClipped: ImRect,
    pub InnerRect: ImRect,
    pub InnerClipRect: ImRect,
    pub WorkRect: ImRect,
    pub ParentWorkRect: ImRect,
    pub ClipRect: ImRect,
    pub ContentRegionRect: ImRect,
    pub HitTestHoleSize: ImVec2ih,
    pub HitTestHoleOffset: ImVec2ih,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub LastFrameJustFocused: ::std::os::raw::c_int,
    pub LastTimeActive: f32,
    pub ItemWidthDefault: f32,
    pub StateStorage: ImGuiStorage,
    pub ColumnsStorage: ImVector_ImGuiOldColumns,
    pub FontWindowScale: f32,
    pub FontWindowScaleParents: f32,
    pub FontRefSize: f32,
    pub SettingsOffset: ::std::os::raw::c_int,
    pub DrawList: *mut ImDrawList,
    pub DrawListInst: ImDrawList,
    pub ParentWindow: *mut ImGuiWindow,
    pub ParentWindowInBeginStack: *mut ImGuiWindow,
    pub RootWindow: *mut ImGuiWindow,
    pub RootWindowPopupTree: *mut ImGuiWindow,
    pub RootWindowDockTree: *mut ImGuiWindow,
    pub RootWindowForTitleBarHighlight: *mut ImGuiWindow,
    pub RootWindowForNav: *mut ImGuiWindow,
    pub ParentWindowForFocusRoute: *mut ImGuiWindow,
    pub NavLastChildNavWindow: *mut ImGuiWindow,
    pub NavLastIds: [ImGuiID; 2usize],
    pub NavRectRel: [ImRect; 2usize],
    pub NavPreferredScoringPosRel: [ImVec2; 2usize],
    pub NavRootFocusScopeId: ImGuiID,
    pub MemoryDrawListIdxCapacity: ::std::os::raw::c_int,
    pub MemoryDrawListVtxCapacity: ::std::os::raw::c_int,
    pub MemoryCompacted: bool,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub DockOrder: ::std::os::raw::c_short,
    pub DockStyle: ImGuiWindowDockStyle,
    pub DockNode: *mut ImGuiDockNode,
    pub DockNodeAsHost: *mut ImGuiDockNode,
    pub DockId: ImGuiID,
}
impl Default for ImGuiWindow {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiWindow {
    #[inline]
    pub fn SetWindowPosAllowFlags(&self) -> ImGuiCond {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowPosAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetWindowPosAllowFlags_raw(this: *const Self) -> ImGuiCond {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetWindowPosAllowFlags_raw(this: *mut Self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SetWindowSizeAllowFlags(&self) -> ImGuiCond {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowSizeAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetWindowSizeAllowFlags_raw(this: *const Self) -> ImGuiCond {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetWindowSizeAllowFlags_raw(this: *mut Self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SetWindowCollapsedAllowFlags(&self) -> ImGuiCond {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowCollapsedAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetWindowCollapsedAllowFlags_raw(this: *const Self) -> ImGuiCond {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetWindowCollapsedAllowFlags_raw(this: *mut Self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SetWindowDockAllowFlags(&self) -> ImGuiCond {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowDockAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetWindowDockAllowFlags_raw(this: *const Self) -> ImGuiCond {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetWindowDockAllowFlags_raw(this: *mut Self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SetWindowPosAllowFlags: ImGuiCond,
        SetWindowSizeAllowFlags: ImGuiCond,
        SetWindowCollapsedAllowFlags: ImGuiCond,
        SetWindowDockAllowFlags: ImGuiCond,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SetWindowPosAllowFlags: u32 =
                unsafe { ::std::mem::transmute(SetWindowPosAllowFlags) };
            SetWindowPosAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let SetWindowSizeAllowFlags: u32 =
                unsafe { ::std::mem::transmute(SetWindowSizeAllowFlags) };
            SetWindowSizeAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let SetWindowCollapsedAllowFlags: u32 =
                unsafe { ::std::mem::transmute(SetWindowCollapsedAllowFlags) };
            SetWindowCollapsedAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let SetWindowDockAllowFlags: u32 =
                unsafe { ::std::mem::transmute(SetWindowDockAllowFlags) };
            SetWindowDockAllowFlags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn DockIsActive(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockIsActive(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockIsActive_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DockIsActive_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DockNodeIsVisible(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockNodeIsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockNodeIsVisible_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DockNodeIsVisible_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DockTabIsVisible(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockTabIsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockTabIsVisible_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DockTabIsVisible_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DockTabWantClose(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockTabWantClose(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockTabWantClose_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DockTabWantClose_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        DockIsActive: bool,
        DockNodeIsVisible: bool,
        DockTabIsVisible: bool,
        DockTabWantClose: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DockIsActive: u8 = unsafe { ::std::mem::transmute(DockIsActive) };
            DockIsActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DockNodeIsVisible: u8 = unsafe { ::std::mem::transmute(DockNodeIsVisible) };
            DockNodeIsVisible as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DockTabIsVisible: u8 = unsafe { ::std::mem::transmute(DockTabIsVisible) };
            DockTabIsVisible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DockTabWantClose: u8 = unsafe { ::std::mem::transmute(DockTabWantClose) };
            DockTabWantClose as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ImGuiTabItem {
    pub ID: ImGuiID,
    pub Flags: ImGuiTabItemFlags,
    pub Window: *mut ImGuiWindow,
    pub LastFrameVisible: ::std::os::raw::c_int,
    pub LastFrameSelected: ::std::os::raw::c_int,
    pub Offset: f32,
    pub Width: f32,
    pub ContentWidth: f32,
    pub RequestedWidth: f32,
    pub NameOffset: ImS32,
    pub BeginOrder: ImS16,
    pub IndexDuringLayout: ImS16,
    pub WantClose: bool,
}
impl Default for ImGuiTabItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTabItem {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTabItem,
}
impl Default for ImVector_ImGuiTabItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTabBar {
    pub Window: *mut ImGuiWindow,
    pub Tabs: ImVector_ImGuiTabItem,
    pub Flags: ImGuiTabBarFlags,
    pub ID: ImGuiID,
    pub SelectedTabId: ImGuiID,
    pub NextSelectedTabId: ImGuiID,
    pub VisibleTabId: ImGuiID,
    pub CurrFrameVisible: ::std::os::raw::c_int,
    pub PrevFrameVisible: ::std::os::raw::c_int,
    pub BarRect: ImRect,
    pub BarRectPrevWidth: f32,
    pub CurrTabsContentsHeight: f32,
    pub PrevTabsContentsHeight: f32,
    pub WidthAllTabs: f32,
    pub WidthAllTabsIdeal: f32,
    pub ScrollingAnim: f32,
    pub ScrollingTarget: f32,
    pub ScrollingTargetDistToVisibility: f32,
    pub ScrollingSpeed: f32,
    pub ScrollingRectMinX: f32,
    pub ScrollingRectMaxX: f32,
    pub SeparatorMinX: f32,
    pub SeparatorMaxX: f32,
    pub ReorderRequestTabId: ImGuiID,
    pub ReorderRequestOffset: ImS16,
    pub BeginCount: ImS8,
    pub WantLayout: bool,
    pub VisibleTabWasSubmitted: bool,
    pub TabsAddedNew: bool,
    pub ScrollButtonEnabled: bool,
    pub TabsActiveCount: ImS16,
    pub LastTabItemIdx: ImS16,
    pub ItemSpacingY: f32,
    pub FramePadding: ImVec2,
    pub BackupCursorPos: ImVec2,
    pub TabsNames: ImGuiTextBuffer,
}
impl Default for ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTableColumn {
    pub Flags: ImGuiTableColumnFlags,
    pub WidthGiven: f32,
    pub MinX: f32,
    pub MaxX: f32,
    pub WidthRequest: f32,
    pub WidthAuto: f32,
    pub WidthMax: f32,
    pub StretchWeight: f32,
    pub InitStretchWeightOrWidth: f32,
    pub ClipRect: ImRect,
    pub UserID: ImGuiID,
    pub WorkMinX: f32,
    pub WorkMaxX: f32,
    pub ItemWidth: f32,
    pub ContentMaxXFrozen: f32,
    pub ContentMaxXUnfrozen: f32,
    pub ContentMaxXHeadersUsed: f32,
    pub ContentMaxXHeadersIdeal: f32,
    pub NameOffset: ImS16,
    pub DisplayOrder: ImGuiTableColumnIdx,
    pub IndexWithinEnabledSet: ImGuiTableColumnIdx,
    pub PrevEnabledColumn: ImGuiTableColumnIdx,
    pub NextEnabledColumn: ImGuiTableColumnIdx,
    pub SortOrder: ImGuiTableColumnIdx,
    pub DrawChannelCurrent: ImGuiTableDrawChannelIdx,
    pub DrawChannelFrozen: ImGuiTableDrawChannelIdx,
    pub DrawChannelUnfrozen: ImGuiTableDrawChannelIdx,
    pub IsEnabled: bool,
    pub IsUserEnabled: bool,
    pub IsUserEnabledNextFrame: bool,
    pub IsVisibleX: bool,
    pub IsVisibleY: bool,
    pub IsRequestOutput: bool,
    pub IsSkipItems: bool,
    pub IsPreserveWidthAuto: bool,
    pub NavLayerCurrent: ImS8,
    pub AutoFitQueue: ImU8,
    pub CannotSkipItemsQueue: ImU8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub SortDirectionsAvailList: ImU8,
}
impl Default for ImGuiTableColumn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiTableColumn {
    #[inline]
    pub fn SortDirection(&self) -> ImU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirection(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SortDirection_raw(this: *const Self) -> ImU8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SortDirection_raw(this: *mut Self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SortDirectionsAvailCount(&self) -> ImU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirectionsAvailCount(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SortDirectionsAvailCount_raw(this: *const Self) -> ImU8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SortDirectionsAvailCount_raw(this: *mut Self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SortDirectionsAvailMask(&self) -> ImU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirectionsAvailMask(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SortDirectionsAvailMask_raw(this: *const Self) -> ImU8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SortDirectionsAvailMask_raw(this: *mut Self, val: ImU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SortDirection: ImU8,
        SortDirectionsAvailCount: ImU8,
        SortDirectionsAvailMask: ImU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SortDirection: u8 = unsafe { ::std::mem::transmute(SortDirection) };
            SortDirection as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SortDirectionsAvailCount: u8 =
                unsafe { ::std::mem::transmute(SortDirectionsAvailCount) };
            SortDirectionsAvailCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let SortDirectionsAvailMask: u8 =
                unsafe { ::std::mem::transmute(SortDirectionsAvailMask) };
            SortDirectionsAvailMask as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableCellData {
    pub BgColor: ImU32,
    pub Column: ImGuiTableColumnIdx,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableHeaderData {
    pub Index: ImGuiTableColumnIdx,
    pub TextColor: ImU32,
    pub BgColor0: ImU32,
    pub BgColor1: ImU32,
}
#[repr(C)]
pub struct ImGuiTableInstanceData {
    pub TableInstanceID: ImGuiID,
    pub LastOuterHeight: f32,
    pub LastTopHeadersRowHeight: f32,
    pub LastFrozenHeight: f32,
    pub HoveredRowLast: ::std::os::raw::c_int,
    pub HoveredRowNext: ::std::os::raw::c_int,
}
impl Default for ImGuiTableInstanceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableColumn {
    pub Data: *mut ImGuiTableColumn,
    pub DataEnd: *mut ImGuiTableColumn,
}
impl Default for ImSpan_ImGuiTableColumn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableColumnIdx {
    pub Data: *mut ImGuiTableColumnIdx,
    pub DataEnd: *mut ImGuiTableColumnIdx,
}
impl Default for ImSpan_ImGuiTableColumnIdx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableCellData {
    pub Data: *mut ImGuiTableCellData,
    pub DataEnd: *mut ImGuiTableCellData,
}
impl Default for ImSpan_ImGuiTableCellData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableInstanceData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTableInstanceData,
}
impl Default for ImVector_ImGuiTableInstanceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableColumnSortSpecs {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTableColumnSortSpecs,
}
impl Default for ImVector_ImGuiTableColumnSortSpecs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTable {
    pub ID: ImGuiID,
    pub Flags: ImGuiTableFlags,
    pub RawData: *mut ::std::os::raw::c_void,
    pub TempData: *mut ImGuiTableTempData,
    pub Columns: ImSpan_ImGuiTableColumn,
    pub DisplayOrderToIndex: ImSpan_ImGuiTableColumnIdx,
    pub RowCellData: ImSpan_ImGuiTableCellData,
    pub EnabledMaskByDisplayOrder: ImBitArrayPtr,
    pub EnabledMaskByIndex: ImBitArrayPtr,
    pub VisibleMaskByIndex: ImBitArrayPtr,
    pub SettingsLoadedFlags: ImGuiTableFlags,
    pub SettingsOffset: ::std::os::raw::c_int,
    pub LastFrameActive: ::std::os::raw::c_int,
    pub ColumnsCount: ::std::os::raw::c_int,
    pub CurrentRow: ::std::os::raw::c_int,
    pub CurrentColumn: ::std::os::raw::c_int,
    pub InstanceCurrent: ImS16,
    pub InstanceInteracted: ImS16,
    pub RowPosY1: f32,
    pub RowPosY2: f32,
    pub RowMinHeight: f32,
    pub RowCellPaddingY: f32,
    pub RowTextBaseline: f32,
    pub RowIndentOffsetX: f32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub RowBgColorCounter: ::std::os::raw::c_int,
    pub RowBgColor: [ImU32; 2usize],
    pub BorderColorStrong: ImU32,
    pub BorderColorLight: ImU32,
    pub BorderX1: f32,
    pub BorderX2: f32,
    pub HostIndentX: f32,
    pub MinColumnWidth: f32,
    pub OuterPaddingX: f32,
    pub CellPaddingX: f32,
    pub CellSpacingX1: f32,
    pub CellSpacingX2: f32,
    pub InnerWidth: f32,
    pub ColumnsGivenWidth: f32,
    pub ColumnsAutoFitWidth: f32,
    pub ColumnsStretchSumWeights: f32,
    pub ResizedColumnNextWidth: f32,
    pub ResizeLockMinContentsX2: f32,
    pub RefScale: f32,
    pub AngledHeadersHeight: f32,
    pub AngledHeadersSlope: f32,
    pub OuterRect: ImRect,
    pub InnerRect: ImRect,
    pub WorkRect: ImRect,
    pub InnerClipRect: ImRect,
    pub BgClipRect: ImRect,
    pub Bg0ClipRectForDrawCmd: ImRect,
    pub Bg2ClipRectForDrawCmd: ImRect,
    pub HostClipRect: ImRect,
    pub HostBackupInnerClipRect: ImRect,
    pub OuterWindow: *mut ImGuiWindow,
    pub InnerWindow: *mut ImGuiWindow,
    pub ColumnsNames: ImGuiTextBuffer,
    pub DrawSplitter: *mut ImDrawListSplitter,
    pub InstanceDataFirst: ImGuiTableInstanceData,
    pub InstanceDataExtra: ImVector_ImGuiTableInstanceData,
    pub SortSpecsSingle: ImGuiTableColumnSortSpecs,
    pub SortSpecsMulti: ImVector_ImGuiTableColumnSortSpecs,
    pub SortSpecs: ImGuiTableSortSpecs,
    pub SortSpecsCount: ImGuiTableColumnIdx,
    pub ColumnsEnabledCount: ImGuiTableColumnIdx,
    pub ColumnsEnabledFixedCount: ImGuiTableColumnIdx,
    pub DeclColumnsCount: ImGuiTableColumnIdx,
    pub AngledHeadersCount: ImGuiTableColumnIdx,
    pub HoveredColumnBody: ImGuiTableColumnIdx,
    pub HoveredColumnBorder: ImGuiTableColumnIdx,
    pub HighlightColumnHeader: ImGuiTableColumnIdx,
    pub AutoFitSingleColumn: ImGuiTableColumnIdx,
    pub ResizedColumn: ImGuiTableColumnIdx,
    pub LastResizedColumn: ImGuiTableColumnIdx,
    pub HeldHeaderColumn: ImGuiTableColumnIdx,
    pub ReorderColumn: ImGuiTableColumnIdx,
    pub ReorderColumnDir: ImGuiTableColumnIdx,
    pub LeftMostEnabledColumn: ImGuiTableColumnIdx,
    pub RightMostEnabledColumn: ImGuiTableColumnIdx,
    pub LeftMostStretchedColumn: ImGuiTableColumnIdx,
    pub RightMostStretchedColumn: ImGuiTableColumnIdx,
    pub ContextPopupColumn: ImGuiTableColumnIdx,
    pub FreezeRowsRequest: ImGuiTableColumnIdx,
    pub FreezeRowsCount: ImGuiTableColumnIdx,
    pub FreezeColumnsRequest: ImGuiTableColumnIdx,
    pub FreezeColumnsCount: ImGuiTableColumnIdx,
    pub RowCellDataCurrent: ImGuiTableColumnIdx,
    pub DummyDrawChannel: ImGuiTableDrawChannelIdx,
    pub Bg2DrawChannelCurrent: ImGuiTableDrawChannelIdx,
    pub Bg2DrawChannelUnfrozen: ImGuiTableDrawChannelIdx,
    pub NavLayer: ImS8,
    pub IsLayoutLocked: bool,
    pub IsInsideRow: bool,
    pub IsInitializing: bool,
    pub IsSortSpecsDirty: bool,
    pub IsUsingHeaders: bool,
    pub IsContextPopupOpen: bool,
    pub DisableDefaultContextMenu: bool,
    pub IsSettingsRequestLoad: bool,
    pub IsSettingsDirty: bool,
    pub IsDefaultDisplayOrder: bool,
    pub IsResetAllRequest: bool,
    pub IsResetDisplayOrderRequest: bool,
    pub IsUnfrozenRows: bool,
    pub IsDefaultSizingPolicy: bool,
    pub IsActiveIdAliveBeforeTable: bool,
    pub IsActiveIdInTable: bool,
    pub HasScrollbarYCurr: bool,
    pub HasScrollbarYPrev: bool,
    pub MemoryCompacted: bool,
    pub HostSkipItems: bool,
}
impl Default for ImGuiTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiTable {
    #[inline]
    pub fn RowFlags(&self) -> ImGuiTableRowFlags {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RowFlags(&mut self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RowFlags_raw(this: *const Self) -> ImGuiTableRowFlags {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RowFlags_raw(this: *mut Self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LastRowFlags(&self) -> ImGuiTableRowFlags {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_LastRowFlags(&mut self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LastRowFlags_raw(this: *const Self) -> ImGuiTableRowFlags {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LastRowFlags_raw(this: *mut Self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RowFlags: ImGuiTableRowFlags,
        LastRowFlags: ImGuiTableRowFlags,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let RowFlags: u32 = unsafe { ::std::mem::transmute(RowFlags) };
            RowFlags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let LastRowFlags: u32 = unsafe { ::std::mem::transmute(LastRowFlags) };
            LastRowFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableHeaderData {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImGuiTableHeaderData,
}
impl Default for ImVector_ImGuiTableHeaderData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ImGuiTableTempData {
    pub TableIndex: ::std::os::raw::c_int,
    pub LastTimeActive: f32,
    pub AngledHeadersExtraWidth: f32,
    pub AngledHeadersRequests: ImVector_ImGuiTableHeaderData,
    pub UserOuterSize: ImVec2,
    pub DrawSplitter: ImDrawListSplitter,
    pub HostBackupWorkRect: ImRect,
    pub HostBackupParentWorkRect: ImRect,
    pub HostBackupPrevLineSize: ImVec2,
    pub HostBackupCurrLineSize: ImVec2,
    pub HostBackupCursorMaxPos: ImVec2,
    pub HostBackupColumnsOffset: ImVec1,
    pub HostBackupItemWidth: f32,
    pub HostBackupItemWidthStackSize: ::std::os::raw::c_int,
}
impl Default for ImGuiTableTempData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImFontLoader {
    pub Name: *const ::std::os::raw::c_char,
    pub LoaderInit: ::std::option::Option<unsafe extern "C" fn(atlas: *mut ImFontAtlas) -> bool>,
    pub LoaderShutdown: ::std::option::Option<unsafe extern "C" fn(atlas: *mut ImFontAtlas)>,
    pub FontSrcInit: ::std::option::Option<
        unsafe extern "C" fn(atlas: *mut ImFontAtlas, src: *mut ImFontConfig) -> bool,
    >,
    pub FontSrcDestroy: ::std::option::Option<
        unsafe extern "C" fn(atlas: *mut ImFontAtlas, src: *mut ImFontConfig),
    >,
    pub FontSrcContainsGlyph: ::std::option::Option<
        unsafe extern "C" fn(
            atlas: *mut ImFontAtlas,
            src: *mut ImFontConfig,
            codepoint: ImWchar,
        ) -> bool,
    >,
    pub FontBakedInit: ::std::option::Option<
        unsafe extern "C" fn(
            atlas: *mut ImFontAtlas,
            src: *mut ImFontConfig,
            baked: *mut ImFontBaked,
            loader_data_for_baked_src: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub FontBakedDestroy: ::std::option::Option<
        unsafe extern "C" fn(
            atlas: *mut ImFontAtlas,
            src: *mut ImFontConfig,
            baked: *mut ImFontBaked,
            loader_data_for_baked_src: *mut ::std::os::raw::c_void,
        ),
    >,
    pub FontBakedLoadGlyph: ::std::option::Option<
        unsafe extern "C" fn(
            atlas: *mut ImFontAtlas,
            src: *mut ImFontConfig,
            baked: *mut ImFontBaked,
            loader_data_for_baked_src: *mut ::std::os::raw::c_void,
            codepoint: ImWchar,
            out_glyph: *mut ImFontGlyph,
            out_advance_x: *mut f32,
        ) -> bool,
    >,
    pub FontBakedSrcLoaderDataSize: usize,
}
impl Default for ImFontLoader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImFontAtlasRectEntry {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ImFontAtlasRectEntry {
    #[inline]
    pub fn TargetIndex(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_TargetIndex(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetIndex_raw(this: *const Self) -> ::std::os::raw::c_int {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetIndex_raw(this: *mut Self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Generation(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_Generation(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Generation_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Generation_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsUsed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsUsed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsUsed_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsUsed_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetIndex: ::std::os::raw::c_int,
        Generation: ::std::os::raw::c_uint,
        IsUsed: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let TargetIndex: u32 = unsafe { ::std::mem::transmute(TargetIndex) };
            TargetIndex as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let Generation: u32 = unsafe { ::std::mem::transmute(Generation) };
            Generation as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let IsUsed: u32 = unsafe { ::std::mem::transmute(IsUsed) };
            IsUsed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type stbrp_node_im = stbrp_node;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct stbrp_context_opaque {
    pub data: [::std::os::raw::c_char; 80usize],
}
impl Default for stbrp_context_opaque {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_stbrp_node_im {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut stbrp_node_im,
}
impl Default for ImVector_stbrp_node_im {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontAtlasRectEntry {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut ImFontAtlasRectEntry,
}
impl Default for ImVector_ImFontAtlasRectEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontBakedPtr {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Data: *mut *mut ImFontBaked,
}
impl Default for ImVector_ImFontBakedPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImStableVector_ImFontBaked__32 {
    pub Size: ::std::os::raw::c_int,
    pub Capacity: ::std::os::raw::c_int,
    pub Blocks: ImVector_ImFontBakedPtr,
}
impl Default for ImStableVector_ImFontBaked__32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImFontAtlasBuilder {
    pub PackContext: stbrp_context_opaque,
    pub PackNodes: ImVector_stbrp_node_im,
    pub Rects: ImVector_ImTextureRect,
    pub RectsIndex: ImVector_ImFontAtlasRectEntry,
    pub TempBuffer: ImVector_unsigned_char,
    pub RectsIndexFreeListStart: ::std::os::raw::c_int,
    pub RectsPackedCount: ::std::os::raw::c_int,
    pub RectsPackedSurface: ::std::os::raw::c_int,
    pub RectsDiscardedCount: ::std::os::raw::c_int,
    pub RectsDiscardedSurface: ::std::os::raw::c_int,
    pub FrameCount: ::std::os::raw::c_int,
    pub MaxRectSize: ImVec2i,
    pub MaxRectBounds: ImVec2i,
    pub LockDisableResize: bool,
    pub PreloadedAllGlyphsRanges: bool,
    pub BakedPool: ImStableVector_ImFontBaked__32,
    pub BakedMap: ImGuiStorage,
    pub BakedDiscardedCount: ::std::os::raw::c_int,
    pub PackIdMouseCursors: ImFontAtlasRectId,
    pub PackIdLinesTexData: ImFontAtlasRectId,
}
impl Default for ImFontAtlasBuilder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImPlot3DContext {
    _unused: [u8; 0],
}
pub type ImPlot3DCond = ::std::os::raw::c_int;
pub type ImPlot3DCol = ::std::os::raw::c_int;
pub type ImPlot3DStyleVar = ::std::os::raw::c_int;
pub type ImPlot3DMarker = ::std::os::raw::c_int;
pub type ImPlot3DLocation = ::std::os::raw::c_int;
pub type ImAxis3D = ::std::os::raw::c_int;
pub type ImPlane3D = ::std::os::raw::c_int;
pub type ImPlot3DColormap = ::std::os::raw::c_int;
pub type ImPlot3DFlags = ::std::os::raw::c_int;
pub type ImPlot3DItemFlags = ::std::os::raw::c_int;
pub type ImPlot3DScatterFlags = ::std::os::raw::c_int;
pub type ImPlot3DLineFlags = ::std::os::raw::c_int;
pub type ImPlot3DTriangleFlags = ::std::os::raw::c_int;
pub type ImPlot3DQuadFlags = ::std::os::raw::c_int;
pub type ImPlot3DSurfaceFlags = ::std::os::raw::c_int;
pub type ImPlot3DMeshFlags = ::std::os::raw::c_int;
pub type ImPlot3DImageFlags = ::std::os::raw::c_int;
pub type ImPlot3DLegendFlags = ::std::os::raw::c_int;
pub type ImPlot3DAxisFlags = ::std::os::raw::c_int;
pub const ImPlot3DFlags_None: ImPlot3DFlags_ = 0;
pub const ImPlot3DFlags_NoTitle: ImPlot3DFlags_ = 1;
pub const ImPlot3DFlags_NoLegend: ImPlot3DFlags_ = 2;
pub const ImPlot3DFlags_NoMouseText: ImPlot3DFlags_ = 4;
pub const ImPlot3DFlags_NoClip: ImPlot3DFlags_ = 8;
pub const ImPlot3DFlags_NoMenus: ImPlot3DFlags_ = 16;
pub const ImPlot3DFlags_CanvasOnly: ImPlot3DFlags_ = 7;
pub type ImPlot3DFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DCond_None: ImPlot3DCond_ = 0;
pub const ImPlot3DCond_Always: ImPlot3DCond_ = 1;
pub const ImPlot3DCond_Once: ImPlot3DCond_ = 2;
pub type ImPlot3DCond_ = ::std::os::raw::c_uint;
pub const ImPlot3DCol_Line: ImPlot3DCol_ = 0;
pub const ImPlot3DCol_Fill: ImPlot3DCol_ = 1;
pub const ImPlot3DCol_MarkerOutline: ImPlot3DCol_ = 2;
pub const ImPlot3DCol_MarkerFill: ImPlot3DCol_ = 3;
pub const ImPlot3DCol_TitleText: ImPlot3DCol_ = 4;
pub const ImPlot3DCol_InlayText: ImPlot3DCol_ = 5;
pub const ImPlot3DCol_FrameBg: ImPlot3DCol_ = 6;
pub const ImPlot3DCol_PlotBg: ImPlot3DCol_ = 7;
pub const ImPlot3DCol_PlotBorder: ImPlot3DCol_ = 8;
pub const ImPlot3DCol_LegendBg: ImPlot3DCol_ = 9;
pub const ImPlot3DCol_LegendBorder: ImPlot3DCol_ = 10;
pub const ImPlot3DCol_LegendText: ImPlot3DCol_ = 11;
pub const ImPlot3DCol_AxisText: ImPlot3DCol_ = 12;
pub const ImPlot3DCol_AxisGrid: ImPlot3DCol_ = 13;
pub const ImPlot3DCol_AxisTick: ImPlot3DCol_ = 14;
pub const ImPlot3DCol_COUNT: ImPlot3DCol_ = 15;
pub type ImPlot3DCol_ = ::std::os::raw::c_uint;
pub const ImPlot3DStyleVar_LineWeight: ImPlot3DStyleVar_ = 0;
pub const ImPlot3DStyleVar_Marker: ImPlot3DStyleVar_ = 1;
pub const ImPlot3DStyleVar_MarkerSize: ImPlot3DStyleVar_ = 2;
pub const ImPlot3DStyleVar_MarkerWeight: ImPlot3DStyleVar_ = 3;
pub const ImPlot3DStyleVar_FillAlpha: ImPlot3DStyleVar_ = 4;
pub const ImPlot3DStyleVar_PlotDefaultSize: ImPlot3DStyleVar_ = 5;
pub const ImPlot3DStyleVar_PlotMinSize: ImPlot3DStyleVar_ = 6;
pub const ImPlot3DStyleVar_PlotPadding: ImPlot3DStyleVar_ = 7;
pub const ImPlot3DStyleVar_LabelPadding: ImPlot3DStyleVar_ = 8;
pub const ImPlot3DStyleVar_LegendPadding: ImPlot3DStyleVar_ = 9;
pub const ImPlot3DStyleVar_LegendInnerPadding: ImPlot3DStyleVar_ = 10;
pub const ImPlot3DStyleVar_LegendSpacing: ImPlot3DStyleVar_ = 11;
pub const ImPlot3DStyleVar_COUNT: ImPlot3DStyleVar_ = 12;
pub type ImPlot3DStyleVar_ = ::std::os::raw::c_uint;
pub const ImPlot3DMarker_None: ImPlot3DMarker_ = -1;
pub const ImPlot3DMarker_Circle: ImPlot3DMarker_ = 0;
pub const ImPlot3DMarker_Square: ImPlot3DMarker_ = 1;
pub const ImPlot3DMarker_Diamond: ImPlot3DMarker_ = 2;
pub const ImPlot3DMarker_Up: ImPlot3DMarker_ = 3;
pub const ImPlot3DMarker_Down: ImPlot3DMarker_ = 4;
pub const ImPlot3DMarker_Left: ImPlot3DMarker_ = 5;
pub const ImPlot3DMarker_Right: ImPlot3DMarker_ = 6;
pub const ImPlot3DMarker_Cross: ImPlot3DMarker_ = 7;
pub const ImPlot3DMarker_Plus: ImPlot3DMarker_ = 8;
pub const ImPlot3DMarker_Asterisk: ImPlot3DMarker_ = 9;
pub const ImPlot3DMarker_COUNT: ImPlot3DMarker_ = 10;
pub type ImPlot3DMarker_ = ::std::os::raw::c_int;
pub const ImPlot3DItemFlags_None: ImPlot3DItemFlags_ = 0;
pub const ImPlot3DItemFlags_NoLegend: ImPlot3DItemFlags_ = 1;
pub const ImPlot3DItemFlags_NoFit: ImPlot3DItemFlags_ = 2;
pub type ImPlot3DItemFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DScatterFlags_None: ImPlot3DScatterFlags_ = 0;
pub const ImPlot3DScatterFlags_NoLegend: ImPlot3DScatterFlags_ = 1;
pub const ImPlot3DScatterFlags_NoFit: ImPlot3DScatterFlags_ = 2;
pub type ImPlot3DScatterFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DLineFlags_None: ImPlot3DLineFlags_ = 0;
pub const ImPlot3DLineFlags_NoLegend: ImPlot3DLineFlags_ = 1;
pub const ImPlot3DLineFlags_NoFit: ImPlot3DLineFlags_ = 2;
pub const ImPlot3DLineFlags_Segments: ImPlot3DLineFlags_ = 1024;
pub const ImPlot3DLineFlags_Loop: ImPlot3DLineFlags_ = 2048;
pub const ImPlot3DLineFlags_SkipNaN: ImPlot3DLineFlags_ = 4096;
pub type ImPlot3DLineFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DTriangleFlags_None: ImPlot3DTriangleFlags_ = 0;
pub const ImPlot3DTriangleFlags_NoLegend: ImPlot3DTriangleFlags_ = 1;
pub const ImPlot3DTriangleFlags_NoFit: ImPlot3DTriangleFlags_ = 2;
pub const ImPlot3DTriangleFlags_NoLines: ImPlot3DTriangleFlags_ = 1024;
pub const ImPlot3DTriangleFlags_NoFill: ImPlot3DTriangleFlags_ = 2048;
pub const ImPlot3DTriangleFlags_NoMarkers: ImPlot3DTriangleFlags_ = 4096;
pub type ImPlot3DTriangleFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DQuadFlags_None: ImPlot3DQuadFlags_ = 0;
pub const ImPlot3DQuadFlags_NoLegend: ImPlot3DQuadFlags_ = 1;
pub const ImPlot3DQuadFlags_NoFit: ImPlot3DQuadFlags_ = 2;
pub const ImPlot3DQuadFlags_NoLines: ImPlot3DQuadFlags_ = 1024;
pub const ImPlot3DQuadFlags_NoFill: ImPlot3DQuadFlags_ = 2048;
pub const ImPlot3DQuadFlags_NoMarkers: ImPlot3DQuadFlags_ = 4096;
pub type ImPlot3DQuadFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DSurfaceFlags_None: ImPlot3DSurfaceFlags_ = 0;
pub const ImPlot3DSurfaceFlags_NoLegend: ImPlot3DSurfaceFlags_ = 1;
pub const ImPlot3DSurfaceFlags_NoFit: ImPlot3DSurfaceFlags_ = 2;
pub const ImPlot3DSurfaceFlags_NoLines: ImPlot3DSurfaceFlags_ = 1024;
pub const ImPlot3DSurfaceFlags_NoFill: ImPlot3DSurfaceFlags_ = 2048;
pub const ImPlot3DSurfaceFlags_NoMarkers: ImPlot3DSurfaceFlags_ = 4096;
pub type ImPlot3DSurfaceFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DMeshFlags_None: ImPlot3DMeshFlags_ = 0;
pub const ImPlot3DMeshFlags_NoLegend: ImPlot3DMeshFlags_ = 1;
pub const ImPlot3DMeshFlags_NoFit: ImPlot3DMeshFlags_ = 2;
pub const ImPlot3DMeshFlags_NoLines: ImPlot3DMeshFlags_ = 1024;
pub const ImPlot3DMeshFlags_NoFill: ImPlot3DMeshFlags_ = 2048;
pub const ImPlot3DMeshFlags_NoMarkers: ImPlot3DMeshFlags_ = 4096;
pub type ImPlot3DMeshFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DImageFlags_None: ImPlot3DImageFlags_ = 0;
pub const ImPlot3DImageFlags_NoLegend: ImPlot3DImageFlags_ = 1;
pub const ImPlot3DImageFlags_NoFit: ImPlot3DImageFlags_ = 2;
pub type ImPlot3DImageFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DLegendFlags_None: ImPlot3DLegendFlags_ = 0;
pub const ImPlot3DLegendFlags_NoButtons: ImPlot3DLegendFlags_ = 1;
pub const ImPlot3DLegendFlags_NoHighlightItem: ImPlot3DLegendFlags_ = 2;
pub const ImPlot3DLegendFlags_Horizontal: ImPlot3DLegendFlags_ = 4;
pub type ImPlot3DLegendFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DLocation_Center: ImPlot3DLocation_ = 0;
pub const ImPlot3DLocation_North: ImPlot3DLocation_ = 1;
pub const ImPlot3DLocation_South: ImPlot3DLocation_ = 2;
pub const ImPlot3DLocation_West: ImPlot3DLocation_ = 4;
pub const ImPlot3DLocation_East: ImPlot3DLocation_ = 8;
pub const ImPlot3DLocation_NorthWest: ImPlot3DLocation_ = 5;
pub const ImPlot3DLocation_NorthEast: ImPlot3DLocation_ = 9;
pub const ImPlot3DLocation_SouthWest: ImPlot3DLocation_ = 6;
pub const ImPlot3DLocation_SouthEast: ImPlot3DLocation_ = 10;
pub type ImPlot3DLocation_ = ::std::os::raw::c_uint;
pub const ImPlot3DAxisFlags_None: ImPlot3DAxisFlags_ = 0;
pub const ImPlot3DAxisFlags_NoLabel: ImPlot3DAxisFlags_ = 1;
pub const ImPlot3DAxisFlags_NoGridLines: ImPlot3DAxisFlags_ = 2;
pub const ImPlot3DAxisFlags_NoTickMarks: ImPlot3DAxisFlags_ = 4;
pub const ImPlot3DAxisFlags_NoTickLabels: ImPlot3DAxisFlags_ = 8;
pub const ImPlot3DAxisFlags_LockMin: ImPlot3DAxisFlags_ = 16;
pub const ImPlot3DAxisFlags_LockMax: ImPlot3DAxisFlags_ = 32;
pub const ImPlot3DAxisFlags_AutoFit: ImPlot3DAxisFlags_ = 64;
pub const ImPlot3DAxisFlags_Invert: ImPlot3DAxisFlags_ = 128;
pub const ImPlot3DAxisFlags_PanStretch: ImPlot3DAxisFlags_ = 256;
pub const ImPlot3DAxisFlags_Lock: ImPlot3DAxisFlags_ = 48;
pub const ImPlot3DAxisFlags_NoDecorations: ImPlot3DAxisFlags_ = 11;
pub type ImPlot3DAxisFlags_ = ::std::os::raw::c_uint;
pub const ImPlot3DColormap_Deep: ImPlot3DColormap_ = 0;
pub const ImPlot3DColormap_Dark: ImPlot3DColormap_ = 1;
pub const ImPlot3DColormap_Pastel: ImPlot3DColormap_ = 2;
pub const ImPlot3DColormap_Paired: ImPlot3DColormap_ = 3;
pub const ImPlot3DColormap_Viridis: ImPlot3DColormap_ = 4;
pub const ImPlot3DColormap_Plasma: ImPlot3DColormap_ = 5;
pub const ImPlot3DColormap_Hot: ImPlot3DColormap_ = 6;
pub const ImPlot3DColormap_Cool: ImPlot3DColormap_ = 7;
pub const ImPlot3DColormap_Pink: ImPlot3DColormap_ = 8;
pub const ImPlot3DColormap_Jet: ImPlot3DColormap_ = 9;
pub const ImPlot3DColormap_Twilight: ImPlot3DColormap_ = 10;
pub const ImPlot3DColormap_RdBu: ImPlot3DColormap_ = 11;
pub const ImPlot3DColormap_BrBG: ImPlot3DColormap_ = 12;
pub const ImPlot3DColormap_PiYG: ImPlot3DColormap_ = 13;
pub const ImPlot3DColormap_Spectral: ImPlot3DColormap_ = 14;
pub const ImPlot3DColormap_Greys: ImPlot3DColormap_ = 15;
pub type ImPlot3DColormap_ = ::std::os::raw::c_uint;
pub type ImPlot3DFormatter = ::std::option::Option<
    unsafe extern "C" fn(
        value: f32,
        buff: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DPoint {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DRay {
    pub Origin: ImPlot3DPoint,
    pub Direction: ImPlot3DPoint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DPlane {
    pub Point: ImPlot3DPoint,
    pub Normal: ImPlot3DPoint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DBox {
    pub Min: ImPlot3DPoint,
    pub Max: ImPlot3DPoint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DRange {
    pub Min: f32,
    pub Max: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImPlot3DQuat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
pub struct ImPlot3DStyle {
    pub LineWeight: f32,
    pub Marker: ::std::os::raw::c_int,
    pub MarkerSize: f32,
    pub MarkerWeight: f32,
    pub FillAlpha: f32,
    pub PlotDefaultSize: ImVec2,
    pub PlotMinSize: ImVec2,
    pub PlotPadding: ImVec2,
    pub LabelPadding: ImVec2,
    pub LegendPadding: ImVec2,
    pub LegendInnerPadding: ImVec2,
    pub LegendSpacing: ImVec2,
    pub Colors: [ImVec4; 15usize],
    pub Colormap: ImPlot3DColormap,
}
impl Default for ImPlot3DStyle {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn ImPlot3D_CreateContext() -> *mut ImPlot3DContext;
}
unsafe extern "C" {
    pub fn ImPlot3D_DestroyContext(ctx: *mut ImPlot3DContext);
}
unsafe extern "C" {
    pub fn ImPlot3D_GetCurrentContext() -> *mut ImPlot3DContext;
}
unsafe extern "C" {
    pub fn ImPlot3D_SetCurrentContext(ctx: *mut ImPlot3DContext);
}
unsafe extern "C" {
    pub fn ImPlot3D_BeginPlot(
        title_id: *const ::std::os::raw::c_char,
        size: ImVec2,
        flags: ImPlot3DFlags,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ImPlot3D_EndPlot();
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxis(
        axis: ImAxis3D,
        label: *const ::std::os::raw::c_char,
        flags: ImPlot3DAxisFlags,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisLimits(axis: ImAxis3D, v_min: f64, v_max: f64, cond: ImPlot3DCond);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisFormat(
        axis: ImAxis3D,
        formatter: ImPlot3DFormatter,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisTicks_doublePtr(
        axis: ImAxis3D,
        values: *const f64,
        n_ticks: ::std::os::raw::c_int,
        labels: *const *const ::std::os::raw::c_char,
        keep_default: bool,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisTicks_double(
        axis: ImAxis3D,
        v_min: f64,
        v_max: f64,
        n_ticks: ::std::os::raw::c_int,
        labels: *const *const ::std::os::raw::c_char,
        keep_default: bool,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisLimitsConstraints(axis: ImAxis3D, v_min: f64, v_max: f64);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxisZoomConstraints(axis: ImAxis3D, z_min: f64, z_max: f64);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxes(
        x_label: *const ::std::os::raw::c_char,
        y_label: *const ::std::os::raw::c_char,
        z_label: *const ::std::os::raw::c_char,
        x_flags: ImPlot3DAxisFlags,
        y_flags: ImPlot3DAxisFlags,
        z_flags: ImPlot3DAxisFlags,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupAxesLimits(
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        z_min: f64,
        z_max: f64,
        cond: ImPlot3DCond,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupBoxRotation_Float(
        elevation: f32,
        azimuth: f32,
        animate: bool,
        cond: ImPlot3DCond,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupBoxRotation_Plot3DQuat(
        rotation: ImPlot3DQuat,
        animate: bool,
        cond: ImPlot3DCond,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupBoxInitialRotation_Float(elevation: f32, azimuth: f32);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupBoxInitialRotation_Plot3DQuat(rotation: ImPlot3DQuat);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupBoxScale(x: f32, y: f32, z: f32);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetupLegend(location: ImPlot3DLocation, flags: ImPlot3DLegendFlags);
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_FloatPtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f32,
        ys: *const f32,
        zs: *const f32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_doublePtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f64,
        ys: *const f64,
        zs: *const f64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_S8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS8,
        ys: *const ImS8,
        zs: *const ImS8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_U8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU8,
        ys: *const ImU8,
        zs: *const ImU8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_S16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS16,
        ys: *const ImS16,
        zs: *const ImS16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_U16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU16,
        ys: *const ImU16,
        zs: *const ImU16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_S32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS32,
        ys: *const ImS32,
        zs: *const ImS32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_U32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU32,
        ys: *const ImU32,
        zs: *const ImU32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_S64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS64,
        ys: *const ImS64,
        zs: *const ImS64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotScatter_U64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU64,
        ys: *const ImU64,
        zs: *const ImU64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DScatterFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_FloatPtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f32,
        ys: *const f32,
        zs: *const f32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_doublePtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f64,
        ys: *const f64,
        zs: *const f64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_S8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS8,
        ys: *const ImS8,
        zs: *const ImS8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_U8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU8,
        ys: *const ImU8,
        zs: *const ImU8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_S16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS16,
        ys: *const ImS16,
        zs: *const ImS16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_U16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU16,
        ys: *const ImU16,
        zs: *const ImU16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_S32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS32,
        ys: *const ImS32,
        zs: *const ImS32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_U32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU32,
        ys: *const ImU32,
        zs: *const ImU32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_S64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS64,
        ys: *const ImS64,
        zs: *const ImS64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotLine_U64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU64,
        ys: *const ImU64,
        zs: *const ImU64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DLineFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_FloatPtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f32,
        ys: *const f32,
        zs: *const f32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_doublePtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f64,
        ys: *const f64,
        zs: *const f64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_S8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS8,
        ys: *const ImS8,
        zs: *const ImS8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_U8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU8,
        ys: *const ImU8,
        zs: *const ImU8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_S16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS16,
        ys: *const ImS16,
        zs: *const ImS16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_U16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU16,
        ys: *const ImU16,
        zs: *const ImU16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_S32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS32,
        ys: *const ImS32,
        zs: *const ImS32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_U32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU32,
        ys: *const ImU32,
        zs: *const ImU32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_S64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS64,
        ys: *const ImS64,
        zs: *const ImS64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotTriangle_U64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU64,
        ys: *const ImU64,
        zs: *const ImU64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DTriangleFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_FloatPtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f32,
        ys: *const f32,
        zs: *const f32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_doublePtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f64,
        ys: *const f64,
        zs: *const f64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_S8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS8,
        ys: *const ImS8,
        zs: *const ImS8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_U8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU8,
        ys: *const ImU8,
        zs: *const ImU8,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_S16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS16,
        ys: *const ImS16,
        zs: *const ImS16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_U16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU16,
        ys: *const ImU16,
        zs: *const ImU16,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_S32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS32,
        ys: *const ImS32,
        zs: *const ImS32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_U32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU32,
        ys: *const ImU32,
        zs: *const ImU32,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_S64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS64,
        ys: *const ImS64,
        zs: *const ImS64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotQuad_U64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU64,
        ys: *const ImU64,
        zs: *const ImU64,
        count: ::std::os::raw::c_int,
        flags: ImPlot3DQuadFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_FloatPtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f32,
        ys: *const f32,
        zs: *const f32,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_doublePtr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const f64,
        ys: *const f64,
        zs: *const f64,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_S8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS8,
        ys: *const ImS8,
        zs: *const ImS8,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_U8Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU8,
        ys: *const ImU8,
        zs: *const ImU8,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_S16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS16,
        ys: *const ImS16,
        zs: *const ImS16,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_U16Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU16,
        ys: *const ImU16,
        zs: *const ImU16,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_S32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS32,
        ys: *const ImS32,
        zs: *const ImS32,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_U32Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU32,
        ys: *const ImU32,
        zs: *const ImU32,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_S64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImS64,
        ys: *const ImS64,
        zs: *const ImS64,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotSurface_U64Ptr(
        label_id: *const ::std::os::raw::c_char,
        xs: *const ImU64,
        ys: *const ImU64,
        zs: *const ImU64,
        x_count: ::std::os::raw::c_int,
        y_count: ::std::os::raw::c_int,
        scale_min: f64,
        scale_max: f64,
        flags: ImPlot3DSurfaceFlags,
        offset: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotMesh(
        label_id: *const ::std::os::raw::c_char,
        vtx: *const ImPlot3DPoint,
        idx: *const ::std::os::raw::c_uint,
        vtx_count: ::std::os::raw::c_int,
        idx_count: ::std::os::raw::c_int,
        flags: ImPlot3DMeshFlags,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotImage_Vec2(
        label_id: *const ::std::os::raw::c_char,
        tex_ref: ImTextureRef,
        center: ImPlot3DPoint,
        axis_u: ImPlot3DPoint,
        axis_v: ImPlot3DPoint,
        uv0: ImVec2,
        uv1: ImVec2,
        tint_col: ImVec4,
        flags: ImPlot3DImageFlags,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotImage_Plot3DPoInt(
        label_id: *const ::std::os::raw::c_char,
        tex_ref: ImTextureRef,
        p0: ImPlot3DPoint,
        p1: ImPlot3DPoint,
        p2: ImPlot3DPoint,
        p3: ImPlot3DPoint,
        uv0: ImVec2,
        uv1: ImVec2,
        uv2: ImVec2,
        uv3: ImVec2,
        tint_col: ImVec4,
        flags: ImPlot3DImageFlags,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotText(
        text: *const ::std::os::raw::c_char,
        x: f32,
        y: f32,
        z: f32,
        angle: f32,
        pix_offset: ImVec2,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotToPixels_Plot3DPoInt(pOut: *mut ImVec2, point: ImPlot3DPoint);
}
unsafe extern "C" {
    pub fn ImPlot3D_PlotToPixels_double(pOut: *mut ImVec2, x: f64, y: f64, z: f64);
}
unsafe extern "C" {
    pub fn ImPlot3D_PixelsToPlotRay_Vec2(pix: ImVec2) -> ImPlot3DRay;
}
unsafe extern "C" {
    pub fn ImPlot3D_PixelsToPlotRay_double(x: f64, y: f64) -> ImPlot3DRay;
}
unsafe extern "C" {
    pub fn ImPlot3D_PixelsToPlotPlane_Vec2(
        pOut: *mut ImPlot3DPoint,
        pix: ImVec2,
        plane: ImPlane3D,
        mask: bool,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_PixelsToPlotPlane_double(
        pOut: *mut ImPlot3DPoint,
        x: f64,
        y: f64,
        plane: ImPlane3D,
        mask: bool,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_GetPlotPos(pOut: *mut ImVec2);
}
unsafe extern "C" {
    pub fn ImPlot3D_GetPlotSize(pOut: *mut ImVec2);
}
unsafe extern "C" {
    pub fn ImPlot3D_GetPlotDrawList() -> *mut ImDrawList;
}
unsafe extern "C" {
    pub fn ImPlot3D_GetStyle() -> *mut ImPlot3DStyle;
}
unsafe extern "C" {
    pub fn ImPlot3D_SetStyle(style: ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_StyleColorsAuto(dst: *mut ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_StyleColorsDark(dst: *mut ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_StyleColorsLight(dst: *mut ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_StyleColorsClassic(dst: *mut ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushStyleColor_U32(idx: ImPlot3DCol, col: ImU32);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushStyleColor_Vec4(idx: ImPlot3DCol, col: ImVec4);
}
unsafe extern "C" {
    pub fn ImPlot3D_PopStyleColor(count: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushStyleVar_Float(idx: ImPlot3DStyleVar, val: f32);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushStyleVar_Int(idx: ImPlot3DStyleVar, val: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushStyleVar_Vec2(idx: ImPlot3DStyleVar, val: ImVec2);
}
unsafe extern "C" {
    pub fn ImPlot3D_PopStyleVar(count: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetNextLineStyle(col: ImVec4, weight: f32);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetNextFillStyle(col: ImVec4, alpha_mod: f32);
}
unsafe extern "C" {
    pub fn ImPlot3D_SetNextMarkerStyle(
        marker: ImPlot3DMarker,
        size: f32,
        fill: ImVec4,
        weight: f32,
        outline: ImVec4,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_GetStyleColorVec4(pOut: *mut ImVec4, idx: ImPlot3DCol);
}
unsafe extern "C" {
    pub fn ImPlot3D_GetStyleColorU32(idx: ImPlot3DCol) -> ImU32;
}
unsafe extern "C" {
    pub fn ImPlot3D_AddColormap_Vec4Ptr(
        name: *const ::std::os::raw::c_char,
        cols: *const ImVec4,
        size: ::std::os::raw::c_int,
        qual: bool,
    ) -> ImPlot3DColormap;
}
unsafe extern "C" {
    pub fn ImPlot3D_AddColormap_U32Ptr(
        name: *const ::std::os::raw::c_char,
        cols: *const ImU32,
        size: ::std::os::raw::c_int,
        qual: bool,
    ) -> ImPlot3DColormap;
}
unsafe extern "C" {
    pub fn ImPlot3D_GetColormapCount() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ImPlot3D_GetColormapName(cmap: ImPlot3DColormap) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ImPlot3D_GetColormapIndex(name: *const ::std::os::raw::c_char) -> ImPlot3DColormap;
}
unsafe extern "C" {
    pub fn ImPlot3D_PushColormap_Plot3DColormap(cmap: ImPlot3DColormap);
}
unsafe extern "C" {
    pub fn ImPlot3D_PushColormap_Str(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn ImPlot3D_PopColormap(count: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ImPlot3D_NextColormapColor(pOut: *mut ImVec4);
}
unsafe extern "C" {
    pub fn ImPlot3D_GetColormapSize(cmap: ImPlot3DColormap) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ImPlot3D_GetColormapColor(
        pOut: *mut ImVec4,
        idx: ::std::os::raw::c_int,
        cmap: ImPlot3DColormap,
    );
}
unsafe extern "C" {
    pub fn ImPlot3D_SampleColormap(pOut: *mut ImVec4, t: f32, cmap: ImPlot3DColormap);
}
unsafe extern "C" {
    pub fn ImPlot3D_ShowDemoWindow(p_open: *mut bool);
}
unsafe extern "C" {
    pub fn ImPlot3D_ShowAllDemos();
}
unsafe extern "C" {
    pub fn ImPlot3D_ShowStyleEditor(ref_: *mut ImPlot3DStyle);
}
unsafe extern "C" {
    pub fn ImPlot3D_ShowMetricsWindow(p_popen: *mut bool);
}
